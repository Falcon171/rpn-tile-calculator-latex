%!TEX root = ../Thesis.tex

\section{Anhang - Quelltext}

\subsection{Model}

\subsubsection{Calculation}

\begin{lstlisting}[caption=Action (Schwenke),label=list:Action,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import de.fhdw.wip.rpntilecalculator.model.operands.Operand;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import java.lang.reflect.InvocationTargetException;
import java.util.List;

/**
 * Summary: The framework for defining Actions. Actions are able to work with operands from the stack or executor functions.
 * Author:  Tim Schwenke
 * Date:    2020/01/04
 */
public abstract class Action {

    /**
     * Must be set by inheriting classes of {@link Action} for reflection to work.
     */
    protected Action scopedAction;

    /**
     * Must be overridden in case the required number of operands is a fixed amount.
     */
    protected int[] requiredNumOfOperands = new int[]{-1};

    /**
     * Leverages reflection for matching given arguments to a calculation method.
     *
     * @param operands List of operands.
     * @return Always a valid Operand.
     * @throws CalculationException In case the result cannot be computed.
     */
    @Contract(pure = true)
    public @NotNull Operand with(@NotNull List<Operand> operands) throws CalculationException {
        Operand[] target = new Operand[operands.size()];
        for (int i = 0; i < target.length; i++) {
            target[i] = operands.get(i);
        }
        return with(target);
    }

	/**
     * Leverages reflection for matching given arguments to a calculation method.
     *
     * @param operands List of operands.
     * @return Always a valid Operand.
     * @throws CalculationException In case the result cannot be computed.
     */
    @Contract(pure = true) public @NotNull Operand with(@NotNull Operand... operands) throws CalculationException {
        Class[] operandClasses = new Class[operands.length];
        Operand resultOperand;

        for (int i = 0; i < operands.length; i++)
            operandClasses[i] = operands[i].getClass();

        try {
            resultOperand = (Operand) scopedAction.getClass()
                    .getDeclaredMethod(
                            "on",
                            operandClasses
                    ).invoke(
                            scopedAction,
                            (Object[]) operands
                    );
        } catch (RuntimeException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
            throw new CalculationException(e.getMessage());
        }

        if (resultOperand != null) return resultOperand;
        else throw new CalculationException();
    }

    /**
     * @return Number of required operands for the concrete {@link Action}. If {@code -1}
     * the number of operands required is variable.
     */
    public int[] getRequiredNumOfOperands() {
        return requiredNumOfOperands;
    }

}
\end{lstlisting}    

\begin{lstlisting}[caption=ArcCosinus (Keienburg),label=list:ArcCosinus,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import de.fhdw.wip.rpntilecalculator.model.operands.Operand;

/*
 * Summary: Defines the arc Cosinus action.
 * Author:  Jannis Luca Keienburg
 * Date:    2020/01/04
 */

public class ArcCosinus extends Action {

    @NotNull
    private static final ArcCosinus ARC_COSINUS = new ArcCosinus();

    /*
     * Singleton for COSINUS
     * @return singleton object
     */
    @Contract(pure = true) @NotNull public static ArcCosinus getInstance() { return ARC_COSINUS; }
    private ArcCosinus() {
        requiredNumOfOperands = new int[]{1};
    }

    @NotNull @Override
    public Operand with(@NotNull Operand... operands) throws CalculationException {
        scopedAction = this;
        return super.with(operands);
    }

    /**
     * Calculates the arc cosinus with a given angle.
     *
     * @param angle Representing the angle.
     * @return Result
     */
    @Contract(pure = true) @NotNull ODouble on(@NotNull ODouble angle) {
        return new ODouble(Math.acos(Math.toRadians((angle.getDouble()))));
    }
}
\end{lstlisting}    

\begin{lstlisting}[caption=ArcSinus (Keienburg),label=list:ArcSinus,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import de.fhdw.wip.rpntilecalculator.model.operands.Operand;

/*
 * Summary: Defines the arc Sinus action.
 * Author:  Jannis Luca Keienburg
 * Date:    2020/01/04
 */

public class ArcSinus extends Action {

    @NotNull
    private static final ArcSinus ARC_SINUS = new ArcSinus();

    /*
     * Singleton for SINUS
     * @return singleton object
     */
    @Contract(pure = true) @NotNull public static ArcSinus getInstance() { return ARC_SINUS; }
    private ArcSinus() {
        requiredNumOfOperands = new int[]{1};
    }

    @NotNull @Override
    public Operand with(@NotNull Operand... operands) throws CalculationException {
        scopedAction = this;
        return super.with(operands);
    }

    // Calculates the arc sinus with a given angle.
    @Contract(pure = true) @NotNull ODouble on(@NotNull ODouble angle) {
        return new ODouble(Math.asin(Math.toRadians((angle.getDouble()))));
    }
}
\end{lstlisting}    

\begin{lstlisting}[caption=ArcTangens (Keienburg),label=list:ArcTangens,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import de.fhdw.wip.rpntilecalculator.model.operands.Operand;

/*
 * Summary: Defines the arc Tangens action.
 * Author:  Jannis Luca Keienburg
 * Date:    2020/01/04
 */

public class ArcTangens  extends Action {

    @NotNull
    private static final ArcTangens ARC_TANGENS = new ArcTangens();

    /*
     * Singleton for SINUS
     * @return singleton object
     */
    @Contract(pure = true) @NotNull public static ArcTangens getInstance() { return ARC_TANGENS; }
    private ArcTangens() {
        requiredNumOfOperands = new int[]{1};
    }

    @NotNull @Override
    public Operand with(@NotNull Operand... operands) throws CalculationException {
        scopedAction = this;
        return super.with(operands);
    }

    // Calculates the tangens with a given angle.
    @Contract(pure = true) @NotNull ODouble on(@NotNull ODouble angle) {
        return new ODouble(Math.atan(Math.toRadians((angle.getDouble()))));
    }
}
\end{lstlisting}    

\begin{lstlisting}[caption=CalculationException (Schwenke),label=list:CalculationException,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

/**
 * Summary: Main Exception for a failed Calculation
 * Author:  Tim Schwenke
 * Date:    2020/01/04
 */
public class CalculationException extends Exception {

    /**
     * Create a new Exception
     * @param msg Error Message
     */
    public CalculationException(String msg) {
        super(msg);
    }

    /**
     * Create a new standard Exception
     */
    public CalculationException() {
        this("Not supported");
    }
}
\end{lstlisting}    

\begin{lstlisting}[caption=Cosinus (Keienburg),label=list:Cosinus,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import de.fhdw.wip.rpntilecalculator.model.operands.Operand;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

/*
 * Summary: Defines the Cosinus action.
 * Author:  Jannis Luca Keienburg
 * Date:    2020/01/04
 */
@SuppressWarnings({"unused"})
public class Cosinus extends Action {

    @NotNull
    private static final Cosinus COSINUS = new Cosinus();

    /*
     * Singleton for COSINUS
     * @return singleton object
     */
    @Contract(pure = true) @NotNull public static Cosinus getInstance() { return COSINUS; }
    private Cosinus() {
        requiredNumOfOperands = new int[]{1, 2};
    }

    @NotNull @Override
    public Operand with(@NotNull Operand... operands) throws CalculationException {
        scopedAction = this;
        return super.with(operands);
    }

    // Calculates the cosinus with a given angle.
    @Contract(pure = true) @NotNull ODouble on(@NotNull ODouble angle) {
        return new ODouble(Math.cos(Math.toRadians((angle.getDouble()))));
    }
}
\end{lstlisting}    

\begin{lstlisting}[caption=Derivation (Keienburg),label=list:Derivation,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import de.fhdw.wip.rpntilecalculator.model.operands.OPolynom;
import de.fhdw.wip.rpntilecalculator.model.operands.Operand;

/*
 * Summary: A Class that can calculate the derivate of a function
 * Author:  Jannis Luca Keienburg
 * Date:    2020/01/14
 */

public class Derivation extends Action {

    @NotNull private static final Derivation DERIVATION = new Derivation();

    @Contract(pure = true) @NotNull public static Derivation getInstance() { return DERIVATION; }
    private Derivation() {
        requiredNumOfOperands = new int[]{1};
    }

    @NotNull @Override
    public Operand with(@NotNull Operand... operands) throws CalculationException {
        scopedAction = this;
        return super.with(operands);
    }

    @Contract(pure = true) @NotNull OPolynom on(@NotNull OPolynom oPolynom) {
        return derivate(oPolynom);
    }

    // Structure: via the method getCoefficients()
    // coefficients[n] * x^n + ... + coefficients[1] * x + coefficients[0]

    // Sets the Function into the following formatition:
    // [n]* x^10 + [n-1] *x^9 + ... + [1] * x + [0]
    private double[] getFunctionAsDouble(@NotNull OPolynom oPolynom) {
        return oPolynom.getPolynom().getCoefficients();
    }

    // Calculates the derivation
    // returns it as an OPolynom
    public OPolynom derivate(OPolynom oPolynom)
    {
        double[] function = getFunctionAsDouble(oPolynom);
        double[] derivation = new double[function.length - 1];

        for(int i = function.length - 1; i > 0; i--)
        {
            derivation[i-1] = function[i] * i;
        }
        return new OPolynom(new PolynomialFunction(derivation));
    }
}
\end{lstlisting}    

\begin{lstlisting}[caption=HighAndLowPoints (Keienburg),label=list:HighAndLowPoints,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;

import org.intellij.lang.annotations.JdkConstants;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import de.fhdw.wip.rpntilecalculator.model.operands.OPolynom;
import de.fhdw.wip.rpntilecalculator.model.operands.OTuple;
import de.fhdw.wip.rpntilecalculator.model.operands.Operand;

/*
 * Summary: A Class that can calculate the high and the low points of a function( up to third grade)
 * Author:  Jannis Luca Keienburg
 * Date:    2020/01/16, updated on 2020/01/17
 */

public class HighAndLowPoints extends Action {

    @NotNull private static final HighAndLowPoints HIGH_AND_LOW_POINTS = new HighAndLowPoints();
    @NotNull private static final Derivation DERIVATION = Derivation.getInstance();
    @NotNull private static final Zeros ZEROS = Zeros.getInstance();

    @Contract(pure = true) @NotNull public static HighAndLowPoints getInstance() { return HIGH_AND_LOW_POINTS; }
    private HighAndLowPoints() {
        requiredNumOfOperands = new int[]{1};
    }

    @NotNull @Override
    public Operand with(@NotNull Operand... operands) throws CalculationException {
        scopedAction = this;
        return super.with(operands);
    }

    @Contract(pure = true) @NotNull OTuple on(@NotNull OPolynom oPolynom) {
        return new OTuple(getHighAndLowPoints(oPolynom));
    }

    // Begin. Returns an double array with the following structure
    public double [] getHighAndLowPoints(OPolynom oPolynom)
    {
        double [] result = calculateHighAndLowPoints(oPolynom);
        return result;
    }

    // Sets the Function into the following formatition:
    // [n]* x^10 + [n-1] *x^9 + ... + [1] * x + [0]
    private double[] getFunctionAsDouble(OPolynom oPolynom) {
        return oPolynom.getPolynom().getCoefficients();
    }

    // Calculates the values of the extreme points of a given function.
    // Returns the values as an double array, an uneyual number position stands for the x value,
    // the number at the next position for the y value
    private double[] calculateHighAndLowPoints(OPolynom oPolynom)
    {
        // Calculates the derivation of the funcion.
        OPolynom derivation = DERIVATION.derivate(oPolynom);
        // Calculates the zeros of the function's derivation.
        double [] zeros = ZEROS.calculateZeros(derivation);
        // Gets the funcion as an double array for the calculation.
        double [] functionAsDouble = getFunctionAsDouble(oPolynom);

        // Calculates the y values of the zeros.
        double [] valuesXY = new double[] {};
        int position = -1;
        for(int counter = 0; counter < zeros.length; counter++)
        {
            double currentZero = zeros[counter];
            double yValue = 0;
            for(int counter2 = 0; counter < functionAsDouble.length; counter2++)
            {
                yValue += functionAsDouble[counter] * Math.pow(currentZero,(functionAsDouble.length - counter2 - 1));
            }
            position++;
            valuesXY[position] = currentZero;
            position++;
            valuesXY[position] = yValue;
        }
        return valuesXY;
    }
}
\end{lstlisting}    

\begin{lstlisting}[caption=Integral (Istogu),label=list:Integral,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.apache.commons.math3.analysis.UnivariateFunction;
import org.apache.commons.math3.analysis.integration.SimpsonIntegrator;
import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import de.fhdw.wip.rpntilecalculator.model.operands.OPolynom;
import de.fhdw.wip.rpntilecalculator.model.operands.Operand;

/*
 * Summary: Calculate the antiderivative and integral
 * Author:  Getuart Istogu
 * Date:    2020/01/27
 */

public class Integral extends Action {

    @NotNull private static final Integral INTEGRAL = new Integral();

    @Contract(pure = true) @NotNull public static Integral getInstance() { return INTEGRAL; }
    private Integral() {requiredNumOfOperands = new int[] {3};}

    @NotNull @Override
    public Operand with(@NotNull Operand... operands) throws CalculationException {
        scopedAction = this;
        return super.with(operands);
    }

    @Contract(pure = true) @NotNull ODouble on(@NotNull OPolynom oPolynom, @NotNull ODouble lowerBound, @NotNull ODouble upperBound) {
        return calculateIntegralSimpsons(oPolynom, lowerBound.getDouble(), upperBound.getDouble());
    }
    
    /**
     * Calculates the integral for the specified limit range
     * @param oPolynom Normal PolynomialFunction, not its antiderivative
     * @param lowerBound Lower limit
     * @param upperBound Upper limit
     * @return
     */
    @NotNull
    public ODouble calculateIntegralSimpsons(OPolynom oPolynom, double lowerBound, double upperBound)
    {
        SimpsonIntegrator simpsonIntegrator = new SimpsonIntegrator();
        UnivariateFunction uF = (UnivariateFunction) oPolynom.getPolynom();
        return new ODouble(simpsonIntegrator.integrate(10000, uF, lowerBound, upperBound));
    }

    /**
     * Calculates the antiderivative of the passed function
     * @param oPolynom Examined function
     * @return Its antiderivative
     */
    public OPolynom getAntiderivative(OPolynom oPolynom)
    {
        PolynomialFunction polynomialFunction = oPolynom.getPolynom();

        // 3x^2 -2x +5 == 3rd degree, but 4 coefficients
        // Therefore number of coefficient antiderivative = degree + 2
        int degreeForAntiderivative = polynomialFunction.degree() + 2;

        double[] functionCoefficents = polynomialFunction.getCoefficients();

        double[] antiderivativeCoefficents = new double[degreeForAntiderivative];

        // This value can be of any size. It is referred as "C" in the literature.
        antiderivativeCoefficents[0] = 0;
        for(int i = 1; i < degreeForAntiderivative; i++)
        {
            antiderivativeCoefficents[i] = functionCoefficents[i-1]/((double) i);
        }

        return new OPolynom(new PolynomialFunction(antiderivativeCoefficents));
    }
}
\end{lstlisting}    

\begin{lstlisting}[caption=IntegralTest (Istogu),label=list:IntegralTest,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;
import org.junit.Test;

import de.fhdw.wip.rpntilecalculator.model.operands.OPolynom;

import static org.junit.Assert.*;

/*
 * Summary: Test for the class 'Integral'
 * Author:  Getuart Istogu
 * Date:    2020/01/27
 */

public class IntegralTest {
    private Integral INTEGRAL = Integral.getInstance();

    @Test public void getSimpsonIntegrator_isCorrect() {
        double[] inputCoefficients = new double[]{17, -8, 1};
        OPolynom inputFunction = new OPolynom(new PolynomialFunction(inputCoefficients));

        assertEquals(INTEGRAL.calculateIntegralSimpsons
                (inputFunction, 2, 5).getDouble(), 6, 0.001);
    }

    @Test
    public void getAntiderivative_isCorrect() {

        OPolynom antiderivative = INTEGRAL.getAntiderivative(new OPolynom(new double[] {
                7, 3, 0, -3.21
        }));

        double[] expectedCoefficient = new double[] {
                0, 7, 1.5, 0, -0.8025
        };

        double[] coefficient = antiderivative.getPolynom().getCoefficients();

        assertEquals(coefficient[0], expectedCoefficient[0], 0.001);
        assertEquals(coefficient[1], expectedCoefficient[1], 0.001);
        assertEquals(coefficient[2], expectedCoefficient[2], 0.001);
        assertEquals(coefficient[3], expectedCoefficient[3], 0.001);
        assertEquals(coefficient[4], expectedCoefficient[4], 0.001);
    }
}
\end{lstlisting}    

\begin{lstlisting}[caption=Limes (Istogu),label=list:Limes,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import de.fhdw.wip.rpntilecalculator.model.operands.OPolynom;
import de.fhdw.wip.rpntilecalculator.model.operands.Operand;


/*
 * Summary: Determine limit
 * Author:  Getuart Istogu
 * Date:    2020/01/04
 */
public class Limes extends Action {

    @NotNull private static final Limes LIMES = new Limes();

    @Contract(pure = true) @NotNull public static Limes getInstance() { return LIMES; }
    private Limes() { requiredNumOfOperands = new int[] {2};}

    @NotNull @Override
    public Operand with(@NotNull Operand... operands) throws CalculationException {
        scopedAction = this;
        return super.with(operands);
    }

    @Contract(pure = true) @NotNull ODouble on (@NotNull OPolynom oPolynom, @NotNull ODouble approach) {
        return limit(oPolynom, approach.getDouble());
    }

    /**
     * Calculates the limit of a function at one point
     * @param oPolynom Examined function
     * @param approach Limit point
     * @return Limit value at the defined point
     */
    public ODouble limit(OPolynom oPolynom, double approach) {
        PolynomialFunction polynomialFunction = oPolynom.getPolynom();
        double below = limitFromBelow(polynomialFunction, approach);
        double above = limitFromAbove(polynomialFunction, approach);
        if(below == above)
            return new ODouble(below);
        else
            return new ODouble(Double.NaN);
    }

    /**
     * Calculates the limit of a function at one point from below
     * @param polynomialFunction Examined function
     * @param approach Limit point
     * @return Limit value from below at the defined point
     */
    private double limitFromBelow(PolynomialFunction polynomialFunction, double approach) {

        for (double d = approach - 10; d <= approach; d = approach
                - ((approach - d) / 10)) {
            if (polynomialFunction.value(d) == Double.POSITIVE_INFINITY) {
                return Double.POSITIVE_INFINITY;
            } else if (polynomialFunction.value(d) == Double.NEGATIVE_INFINITY) {
                return Double.NEGATIVE_INFINITY;
            } else if (Double.isNaN(polynomialFunction.value(d))) {
                return polynomialFunction.value(approach + ((approach - d) * 10));
            } else {
                if (d == approach) {
                    return polynomialFunction.value(d);
                } else if (approach - d < 0.00000000001) {
                    d = approach;
                }
            }
        }
        return Double.NaN;
    }

    /**
     * Calculates the limit of a function at one point from above
     * @param polynomialFunction Examined function
     * @param approach Limit point
     * @return Limit value from above at the defined point
     */
    private double limitFromAbove(PolynomialFunction polynomialFunction, double approach) {

        for (double d = approach + 10; d >= approach; d = approach
                - ((approach - d) / 10)) {
            if (polynomialFunction.value(d) == Double.POSITIVE_INFINITY) {
                return Double.POSITIVE_INFINITY;
            } else if (polynomialFunction.value(d) == Double.NEGATIVE_INFINITY) {
                return Double.NEGATIVE_INFINITY;
            } else if (Double.isNaN(polynomialFunction.value(d))) {
                return polynomialFunction.value(approach + ((approach - d) * 10));
            } else {
                if (d == approach) {
                    return polynomialFunction.value(d);
                } else if (d - approach < 0.00000000001) {
                    d = approach;
                }
            }
        }
        return Double.NaN;
    }
}
\end{lstlisting}    

\begin{lstlisting}[caption=LimesTest (Istogu),label=list:LimesTest,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.junit.Test;

import de.fhdw.wip.rpntilecalculator.model.operands.OPolynom;

import static org.junit.Assert.assertEquals;

/*
 * Summary: Test for the class 'Limes'
 * Author:  Getuart Istogu
 * Date:    2020/01/27
 */

public class LimesTest {
    private Limes LIMES = Limes.getInstance();

    @Test
    public void limes_isCorrect1()
    {
        OPolynom polynom = new OPolynom(new double[]{1, 0, 1});
        assertEquals(
                LIMES.limit(polynom, 5).getDouble(), 26, 0.001);
    }

    @Test
    public void limes_isCorrect2()
    {
        OPolynom polynom = new OPolynom(new double[]{0, 0, 2, -0.333333333  });
        assertEquals(
                LIMES.limit(polynom, Double.POSITIVE_INFINITY).getDouble(), Double.NEGATIVE_INFINITY, 0.001);
    }
}
\end{lstlisting}    

\begin{lstlisting}[caption=Logarithm (Keienburg),label=list:Logarithm,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;


import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import de.fhdw.wip.rpntilecalculator.model.operands.Operand;

/*
 * Summary: A Class that can calculate the natural logarithm.
 * Author:  Jannis Luca Keienburg
 * Date:    2020/01/19
 */
public class Logarithm extends Action {

    @NotNull
    private static final Logarithm LOGARITHM = new Logarithm();

    /*
     * Singleton for Logarithm
     * @return singleton object
     */
    @Contract(pure = true) @NotNull public static Logarithm getInstance() { return LOGARITHM; }
    private Logarithm() {
        requiredNumOfOperands = new int[]{1, 2};
    }

    @NotNull @Override
    public Operand with(@NotNull Operand... operands) throws CalculationException {
        scopedAction = this;
        return super.with(operands);
    }

    //Natural Logarithm
    @Contract(pure = true) @NotNull ODouble on(@NotNull ODouble oDouble) {
        if(oDouble.getDouble() <= 0)
            throw new IllegalArgumentException("Value must be higher than Zero.");
        return new ODouble(Math.log(oDouble.getDouble()));
    }

    //Logarithm with specific base
    @Contract(pure = true) @NotNull ODouble on(@NotNull ODouble base, ODouble logartihmOf) {
        if(base.getDouble() <= 0 || logartihmOf.getDouble() <= 0)
            throw new IllegalArgumentException("Value must be higher than Zero.");
        return new ODouble(Math.log(logartihmOf.getDouble()) / Math.log(base.getDouble()));
    }
}
\end{lstlisting}    

\begin{lstlisting}[caption=Logarithm10 (Keienburg),label=list:Logarithm10,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import de.fhdw.wip.rpntilecalculator.model.operands.Operand;

/*
 * Summary: A Class that can calculate the natural logarithm.
 * Author:  Jannis Luca Keienburg
 * Date:    2020/01/19
 */
public class Logarithm10 extends Action {

    @NotNull
    private static final Logarithm10 LOGARITHM10 = new Logarithm10();

    /*
     * Singleton for Logarithm with the base of 10
     * @return singleton object
     */
    @Contract(pure = true) @NotNull public static Logarithm10 getInstance() { return LOGARITHM10; }
    private Logarithm10() {
        requiredNumOfOperands = new int[]{1};
    }

    @NotNull @Override
    public Operand with(@NotNull Operand... operands) throws CalculationException {
        scopedAction = this;
        return super.with(operands);
    }

    //Logarithm to the base of 10
    @Contract(pure = true) @NotNull ODouble on(@NotNull ODouble oDouble) {
        if(oDouble.getDouble() <= 0)
            throw new IllegalArgumentException("Value must be higher than Zero.");
        return new ODouble(Math.log10(oDouble.getDouble()));
    }
}
\end{lstlisting}  

\begin{lstlisting}[caption=MatrixUtil (Istogu),label=list:MatrixUtil,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import de.fhdw.wip.rpntilecalculator.model.operands.OMatrix;
import de.fhdw.wip.rpntilecalculator.model.operands.OSet;
import de.fhdw.wip.rpntilecalculator.model.operands.OTuple;
import de.fhdw.wip.rpntilecalculator.model.operands.Operand;

/*
 * Summary: Solving systems of linear equations with "LR decomposition with column pivot search"
 * Author:  Getuart Istogu
 * Date:    2020/01/27
 */

public class MatrixUtil extends Action {
    @NotNull
    private static final MatrixUtil MATRIX_UTIL  = new MatrixUtil();

    @Contract(pure = true) @NotNull public static MatrixUtil getInstance() { return MATRIX_UTIL; }
    private MatrixUtil() { requiredNumOfOperands = new int[] {2}; }

    @NotNull @Override
    public Operand with(@NotNull Operand... operands) throws CalculationException {
        scopedAction = this;
        return super.with(operands);
    }

    @Contract(pure = true) @NotNull OTuple on (@NotNull OMatrix A, OTuple b) {
        return solveLinearSystem(A, b.getTuple());
    }
    /**
     * On the condition that A*x = b
     * @param A Matrix
     * @param b Solution vector
     * @return Returns the vector 'x'
     */
    public OTuple solveLinearSystem(OMatrix A, double[] b)
    {
        return new OTuple(solveLGSForX(A.getMatrix().getData(), b));
    }

    /**
     * Determines pivot vector
     * @param A The linear system in double[][]
     * @return
     */
    private int[] pivot(double A[][])
    {
        int n = A.length;
        int[] pivot = new int[n];
        for (int j = 0; j < n-1; j++)
        {
            double max = Math.abs(A[j][j]);
            int imax = j;
            for (int i = j+1; i < n; i++)
                if (Math.abs(A[i][j]) > max)
                {
                    max  = Math.abs(A[i][j]);
                    imax = i;
                }
            double[] h = A[j];
            A[j] = A[imax];
            A[imax] = h;
            pivot[j] = imax;
            for (int i = j+1; i < n; i++)
            {
                double f = -A[i][j]/A[j][j];
                for (int k = j+1; k < n; k++)
                    A[i][k] += f*A[j][k];
                A[i][j] = -f;
            }
        }
        return pivot;
    }

    /**
     * Loest das LGS A*x = b nach x auf
     * @param A The linear system in double[][]
     * @param b Solution vector
     * @return Returns the vector 'x'
     */
    private double[] solveLGSForX(double[][] A, double[] b)
    {
        double[][] B = A.clone();
        double[] x = b.clone();
        int[] pivot = pivot(B);
        int n = B.length;
        for (int i = 0; i < n-1; i++)
        {
            double h = b[pivot[i]];
            b[pivot[i]] = b[i];
            b[i] = h;
        }
        for (int j = 0; j < n; j++)
        {
            x[j] = b[j];
            for (int i = 0; i < j; i++)
                x[j] -= B[j][i]*x[i];
        }
        for (int j = n-1; j >= 0; j--)
        {
            for (int k = j+1; k < n; k++)
                x[j] -= B[j][k]*x[k];
            x[j] /= B[j][j];
        }
        return x;
    }
}
\end{lstlisting}    

\begin{lstlisting}[caption=MatrixUtilTest (Istogu), label=list:MatrixUtilTest, language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.junit.Test;

import de.fhdw.wip.rpntilecalculator.model.operands.OMatrix;

import static org.junit.Assert.assertEquals;

/*
 * Summary: Test for the class 'MatrixUtil'
 * Author:  Getuart Istogu
 * Date:    2020/01/27
 */

public class MatrixUtilTest {
    private MatrixUtil MATRIX_UTIL = MatrixUtil.getInstance();

    @Test
    public void solveLinearSystem_isCorrect() {
        double[][] A = {
                {3, -7, 0, -6},
                {2, -8, -1, 4},
                {0, 9, -7, 9},
                {-4, 5, -3, -8}};

        OMatrix aMatrix = new OMatrix(A);
        double[] b = {8, 1, -7, -1};

        double[] exptectedX = {1.1970139565076277, -0.12852969814995122, 0.08276533592989294, -0.5848750405712432};

        double[] x = MATRIX_UTIL.solveLinearSystem(aMatrix, b).getTuple();

        assertEquals(x[0], exptectedX[0], 0.001);
        assertEquals(x[1], exptectedX[1], 0.001);
        assertEquals(x[2], exptectedX[2], 0.001);
        assertEquals(x[3], exptectedX[3], 0.001);
    }

}
\end{lstlisting}

\begin{lstlisting}[caption=Minus (Schwenke),label=list:Minus,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import de.fhdw.wip.rpntilecalculator.model.operands.OFraction;
import de.fhdw.wip.rpntilecalculator.model.operands.OMatrix;
import de.fhdw.wip.rpntilecalculator.model.operands.OPolynom;
import de.fhdw.wip.rpntilecalculator.model.operands.OSet;
import de.fhdw.wip.rpntilecalculator.model.operands.OTuple;
import de.fhdw.wip.rpntilecalculator.model.operands.Operand;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

/*
 * Summary: Defines the Minus click. Lets the user subtract operands.
 * Author:  Tim Schwenke
 * Date:    2020/01/04
 */
public class Minus extends Action {

    @NotNull private static final Plus PLUS = Plus.getInstance();

    @NotNull private static final Minus MINUS = new Minus();

    @Contract(pure = true) @NotNull public static Minus getInstance() { return MINUS; }
    private Minus() {
        requiredNumOfOperands = new int[]{2};
    }

    @NotNull @Override
    public Operand with(@NotNull Operand... operands) throws CalculationException {
        scopedAction = this;
        return super.with(operands);
    }

    //region Double
    //------------------------------------------------------------------------------------

    @Contract(pure = true) @NotNull ODouble on(@NotNull ODouble oDouble1, @NotNull ODouble oDouble2) {
        return new ODouble(oDouble1.getDouble() - oDouble2.getDouble());
    }

    @Contract(pure = true) @NotNull ODouble on(@NotNull ODouble oDouble, @NotNull OFraction oFraction) {
        return new ODouble(oDouble.getDouble() - oFraction.getDouble());
    }

    //endregion

    //region Fraction
    //------------------------------------------------------------------------------------

    @Contract(pure = true) @NotNull OFraction on(@NotNull OFraction oFraction1, @NotNull OFraction oFraction2) {
        return new OFraction(oFraction1.getFraction().subtract(oFraction2.getFraction()));
    }

    @Contract(pure = true) @NotNull ODouble on(@NotNull OFraction oFraction, @NotNull ODouble oDouble) {
        return new ODouble(oFraction.getDouble() - oDouble.getDouble());
    }

    //endregion

    //region Set
    //------------------------------------------------------------------------------------

    @Contract(pure = true) @NotNull OSet on(@NotNull OSet oSet, @NotNull ODouble oDouble) {
        return PLUS.on(oDouble.turnAroundSign(), oSet);
    }

    @Contract(pure = true) @NotNull OSet on(@NotNull OSet oSet, @NotNull OFraction oFraction) {
        return on(oSet, new ODouble(oFraction.getDouble()));
    }

    //endregion

    //region Matrix
    //------------------------------------------------------------------------------------

    @Contract(pure = true) @NotNull OMatrix on(@NotNull OMatrix oMatrix1, @NotNull OMatrix oMatrix2) {
        return new OMatrix(oMatrix1.getMatrix().subtract(oMatrix2.getMatrix()));
    }

    @Contract(pure = true) @NotNull OMatrix on(@NotNull OMatrix oMatrix, @NotNull ODouble oDouble) {
        return new OMatrix(oMatrix.getMatrix().scalarAdd(oDouble.turnAroundSign().getDouble()));
    }

    @Contract(pure = true) @NotNull OMatrix on(@NotNull OMatrix oMatrix, @NotNull OFraction oFraction) {
        return new OMatrix(oMatrix.getMatrix().scalarAdd(oFraction.turnAroundSign().getDouble()));
    }

    //endregion

    //region Polynom
    //------------------------------------------------------------------------------------

    @Contract(pure = true) @NotNull OPolynom on(@NotNull OPolynom oPolynom1, @NotNull OPolynom oPolynom2) {
        return new OPolynom(oPolynom1.getPolynom().subtract(oPolynom2.getPolynom()));
    }

    @Contract(pure = true) @NotNull OPolynom on(@NotNull OPolynom oPolynom, @NotNull ODouble oDouble) {
        return PLUS.on(oDouble.turnAroundSign(), oPolynom);
    }

    @Contract(pure = true) @NotNull OPolynom on(@NotNull OPolynom oPolynom, @NotNull OFraction oFraction) {
        return on(oPolynom, new ODouble(oFraction.getDouble()));
    }

    //endregion

    //region Tuple
    //------------------------------------------------------------------------------------

    @Contract(pure = true) @NotNull OTuple on(@NotNull OTuple oTuple1, @NotNull OTuple oTuple2) {
        return PLUS.on(oTuple1, oTuple2.turnAroundSign());
    }

    @Contract(pure = true) @NotNull OTuple on(@NotNull OTuple oTuple, @NotNull ODouble oDouble) {
        return PLUS.on(oDouble.turnAroundSign(), oTuple);
    }

    @Contract(pure = true) @NotNull OTuple on(@NotNull OTuple oTuple, @NotNull OFraction oFraction) {
        return PLUS.on(oFraction.turnAroundSign(), oTuple);
    }

    //endregion
}
\end{lstlisting}    

\begin{lstlisting}[caption=MinusTest (Schwenke),label=list:MinusTest,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.junit.Test;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import de.fhdw.wip.rpntilecalculator.model.operands.OFraction;
import de.fhdw.wip.rpntilecalculator.model.operands.OMatrix;
import de.fhdw.wip.rpntilecalculator.model.operands.OPolynom;
import de.fhdw.wip.rpntilecalculator.model.operands.OSet;
import de.fhdw.wip.rpntilecalculator.model.operands.OTuple;

import static org.junit.Assert.*;


/*
 * Summary: Test for the class 'MinusTest'
 * Author:  Tim Schwenke
 * Date:    2020/01/27
 */

public class MinusTest {

    private Minus MINUS = Minus.getInstance();

    @Test public void on_DoubleDouble_isCorrect() {
        System.out.println(MINUS.on(
                new ODouble(5),
                new ODouble(5)
        ));

        assertTrue(MINUS.on(
                new ODouble(5),
                new ODouble(5)
                ).equalsValue(new ODouble(0)));
    }

    @Test public void on_DoubleFraction_isCorrect() {
        assertTrue(MINUS.on(
                new ODouble(5),
                new OFraction(1, 2)
        ).equalsValue(new ODouble(4.5)));
    }

    @Test public void on_FractionFraction_isCorrect() {
        assertTrue(MINUS.on(
                new OFraction(1, 1),
                new OFraction(1, 1)
        ).equalsValue(new OFraction(0)));
    }

    @Test public void on_FractionDouble_isCorrect() {
        assertTrue(MINUS.on(
                new OFraction(1, 1),
                new ODouble(1)
        ).equalsValue(new ODouble(0)));
    }

    @Test public void on_SetDouble_isCorrect() {
        assertTrue(MINUS.on(
                new OSet(1, 2),
                new ODouble(1)
        ).equalsValue(new OSet(0, 1)));
    }

    @Test public void on_SetFraction_isCorrect() {
        assertTrue(MINUS.on(
                new OSet(1, 2),
                new OFraction(1, 1)
        ).equalsValue(new OSet(0, 1)));
    }

    @Test public void on_MatrixMatrix_isCorrect() {
        assertTrue(MINUS.on(
                new OMatrix(new double[][]{
                        {1d, 2d, 3d},
                        {1d, 2d, 3d},
                        {1d, 2d, 3d}
                }),
                new OMatrix(new double[][]{
                        {1d, 2d, 3d},
                        {1d, 2d, 3d},
                        {1d, 2d, 3d}
                })
        ).equalsValue(new OMatrix(new double[][]{
                {0d, 0d, 0d},
                {0d, 0d, 0d},
                {0d, 0d, 0d}
        })));
    }

    @Test public void on_MatrixMatrix_isWrongDimension() {
        try {
            MINUS.on(
                    new OMatrix(new double[][]{
                            {1d, 2d, 3d},
                            {1d, 2d, 3d},
                            {1d, 2d, 3d}
                    }),
                    new OMatrix(new double[][]{
                            {1d, 1d},
                            {2d, 3d}
                    })
            );
            fail();
        } catch (RuntimeException e) {
            assertTrue("Should always fail", true);
        }
    }

    @Test public void on_MatrixDouble_isCorrect() {
        assertTrue(MINUS.on(
               new OMatrix(new double[][]{
                       {1, 2, 3},
                       {1, 2, 3}
               }),
               new ODouble(1)
        ).equalsValue(new OMatrix(new double[][]{
                {0, 1, 2},
                {0, 1, 2}
        })));
    }

    @Test public void on_MatrixFraction_isCorrect() {
        assertTrue(MINUS.on(
                new OMatrix(new double[][]{
                        {1, 2, 3},
                        {1, 2, 3}
                }),
                new OFraction(1, 1)
        ).equalsValue(new OMatrix(new double[][]{
                {0, 1, 2},
                {0, 1, 2}
        })));
    }

    @Test public void onPolynomPolynom_isCorrect() {
        assertTrue(MINUS.on(
                new OPolynom(1, 2, 3),
                new OPolynom(2, 0, 5, 6)
        ).equalsValue(new OPolynom(-1, 2, -2, -6)));
    }

    @Test public void on_PolynomFraction_isCorrect() {
        assertTrue(MINUS.on(
                new OPolynom(1, 2, 3),
                new OFraction(1, 1)
        ).equalsValue(new OPolynom(0, 2, 3)));
    }

    @Test public void on_PolynomDouble_isCorrect() {
        assertTrue(MINUS.on(
                new OPolynom(1, 2, 3),
                new ODouble(1)
        ).equalsValue(new OPolynom(0, 2, 3)));
    }

    @Test public void on_TupleTuple_isCorrect() {
        assertTrue(MINUS.on(
                new OTuple(1, 2),
                new OTuple(1, 2)
        ).equalsValue(new OTuple(0, 0)));
    }

    @Test public void on_TupleDouble_isCorrect() {
        assertTrue(MINUS.on(
                new OTuple(1, 2),
                new ODouble(1)
        ).equalsValue(new OTuple(0, 1)));
    }

    @Test public void on_TupleFraction_isCorrect() {
        assertTrue(MINUS.on(
                new OTuple(1, 2),
                new OFraction(1, 1)
        ).equalsValue(new OTuple(0, 1)));
    }
}
\end{lstlisting} 

\begin{lstlisting}[caption=Modulo (Istogu),label=list:Modulo,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import de.fhdw.wip.rpntilecalculator.model.operands.Operand;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Contract;

/*
 * Summary: Defines the Modulo click.
 * Author:  Getuart Istogu
 * Date:    2020/01/05
 */
public class Modulo extends Action {
    @NotNull private static final Modulo MODULO = new Modulo();

    @Contract(pure = true) @NotNull public static Modulo getInstance() { return MODULO; }
    private Modulo() {
        requiredNumOfOperands = new int[]{2};
    }

    @NotNull @Override
    public Operand with(@NotNull Operand... operands) throws CalculationException {
        scopedAction = this;
        return super.with(operands);
    }

    //region Integer
    //------------------------------------------------------------------------------------
    /*
     * Modulo operations. It should be noted that normally it isn't allow to modulo with floating numbers.
     * However it is possible in Java.
     * @return result of the modulo operations
     */
    @Contract(pure = true) @NotNull ODouble on(@NotNull ODouble dividend, @NotNull ODouble divisor) {
        return new ODouble(dividend.getDouble() % divisor.getDouble());
    }
}
\end{lstlisting}    

\begin{lstlisting}[caption=Plus (Schwenke),label=list:Plus,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import de.fhdw.wip.rpntilecalculator.model.operands.OFraction;
import de.fhdw.wip.rpntilecalculator.model.operands.OMatrix;
import de.fhdw.wip.rpntilecalculator.model.operands.OPolynom;
import de.fhdw.wip.rpntilecalculator.model.operands.OSet;
import de.fhdw.wip.rpntilecalculator.model.operands.OTuple;
import de.fhdw.wip.rpntilecalculator.model.operands.Operand;

import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import java.util.HashSet;
import java.util.Set;

/*
 * Summary: Defines the Plus click. Lets the user subtract operands.
 * Author:  Tim Schwenke
 * Date:    2020/01/04
 */
public class Plus extends Action {

    @NotNull private static final Plus PLUS = new Plus();

    @Contract(pure = true) @NotNull public static Plus getInstance() { return PLUS; }
    private Plus() {
        requiredNumOfOperands = new int[]{2};
    }

    @NotNull @Override
    public Operand with(@NotNull Operand... operands) throws CalculationException {
        scopedAction = this;
        return super.with(operands);
    }

    @Contract(pure = true) @NotNull ODouble on(@NotNull ODouble oDouble1, @NotNull ODouble oDouble2) {
        return new ODouble(oDouble1.getDouble() + oDouble2.getDouble());
    }

    @Contract(pure = true) @NotNull ODouble on(@NotNull ODouble oDouble, @NotNull OFraction oFraction) {
        return new ODouble(oDouble.getDouble() + oFraction.getDouble());
    }

    @Contract(pure = true) @NotNull ODouble on(@NotNull OFraction oFraction, @NotNull ODouble oDouble) {
        return on(oDouble, oFraction);
    }

    @Contract(pure = true) @NotNull OSet on(@NotNull ODouble oDouble, @NotNull OSet oSet) {
        Set<Double> newSet = new HashSet<>();
        for (double d : oSet.getSet())
            newSet.add(d + oDouble.getDouble());
        return new OSet(newSet);
    }

    @Contract(pure = true) @NotNull OSet on(@NotNull OSet oSet, @NotNull ODouble oDouble) {
        return on(oDouble, oSet);
    }

    @Contract(pure = true) @NotNull OMatrix on(@NotNull ODouble oDouble, @NotNull OMatrix oMatrix) {
        return new OMatrix(oMatrix.getMatrix().scalarAdd(oDouble.getDouble()));
    }

    @Contract(pure = true) @NotNull OMatrix on(@NotNull OMatrix oMatrix, @NotNull ODouble oDouble) {
        return on(oDouble, oMatrix);
    }

    @Contract(pure = true) @NotNull OPolynom on(@NotNull ODouble oDouble, @NotNull OPolynom oPolynom) {
        double[] d = oPolynom.getPolynom().getCoefficients();
        d[0] += oDouble.getDouble();
        return new OPolynom(new PolynomialFunction(d));
    }

    @Contract(pure = true) @NotNull OPolynom on(@NotNull OPolynom oPolynom, @NotNull ODouble oDouble) {
        return on(oDouble, oPolynom);
    }

    @Contract(pure = true) @NotNull OTuple on(@NotNull ODouble oDouble, @NotNull OTuple oTuple) {
        double[] oldTuple = oTuple.getTuple();
        double[] newTuple = new double[oldTuple.length];
        for (int i = 0; i < newTuple.length; i++)
            newTuple[i] = oDouble.getDouble() + oldTuple[i];
        return new OTuple(newTuple);
    }

    @Contract(pure = true) @NotNull OTuple on(@NotNull OTuple oTuple, @NotNull ODouble oDouble) {
        return on(oDouble, oTuple);
    }

    @Contract(pure = true) @NotNull OFraction on(@NotNull OFraction oFraction1, @NotNull OFraction oFraction2) {
        return new OFraction(oFraction1.getFraction().add(oFraction2.getFraction()));
    }

    @Contract(pure = true) @NotNull OSet on(@NotNull OFraction oFraction, @NotNull OSet oSet) {
        Set<Double> newSet = new HashSet<>();
        for (double d : oSet.getSet())
            newSet.add(d + oFraction.getDouble());
        return new OSet(newSet);
    }

    @Contract(pure = true) @NotNull OSet on(@NotNull OSet oSet, @NotNull OFraction oFraction) {
        return on(oFraction, oSet);
    }

    @Contract(pure = true) @NotNull OMatrix on(@NotNull OFraction oFraction, @NotNull OMatrix oMatrix) {
        return new OMatrix(oMatrix.getMatrix().scalarAdd(oFraction.getDouble()));
    }

    @Contract(pure = true) @NotNull OMatrix on(@NotNull OMatrix oMatrix, @NotNull OFraction oFraction) {
        return on(oFraction, oMatrix);
    }

    @Contract(pure = true) @NotNull OPolynom on(@NotNull OFraction oFraction, @NotNull OPolynom oPolynom) {
        double[] d = oPolynom.getPolynom().getCoefficients();
        d[0] += oFraction.getDouble();
        return new OPolynom(new PolynomialFunction(d));
    }

    @Contract(pure = true) @NotNull OPolynom on(@NotNull OPolynom oPolynom, @NotNull OFraction oFraction) {
        return on(oFraction, oPolynom);
    }

    @Contract(pure = true) @NotNull OTuple on(@NotNull OFraction oFraction, @NotNull OTuple oTuple) {
        double[] oldTuple = oTuple.getTuple();
        double[] newTuple = new double[oldTuple.length];
        double fractionDouble = oFraction.getDouble();
        for (int i = 0; i < newTuple.length; i++)
            newTuple[i] = fractionDouble + oldTuple[i];
        return new OTuple(newTuple);
    }

    @Contract(pure = true) @NotNull OTuple on(@NotNull OTuple oTuple, @NotNull OFraction oFraction) {
        return on(oFraction, oTuple);
    }

    @Contract(pure = true) @NotNull OMatrix on(@NotNull OMatrix oMatrix1, @NotNull OMatrix oMatrix2) {
        return new OMatrix(oMatrix1.getMatrix().add(oMatrix2.getMatrix()));
    }

    @Contract(pure = true) @NotNull OPolynom on(@NotNull OPolynom oPolynom1, @NotNull OPolynom oPolynom2) {
        return new OPolynom(oPolynom1.getPolynom().add(oPolynom2.getPolynom()));
    }

    @Contract(pure = true) @NotNull OTuple on(@NotNull OTuple oTuple1, @NotNull OTuple oTuple2) {
        double[] tuple1 = oTuple1.getTuple();
        double[] tuple2 = oTuple2.getTuple();
        double[] tupleSum = new double[tuple1.length];

        if (tuple1.length != tuple2.length)
            throw new IllegalArgumentException("Tuples must have matching size.");

        for (int i = 0; i < tupleSum.length; i++)
            tupleSum[i] = tuple1[i] + tuple2[i];

        return new OTuple(tupleSum);
    }

}
\end{lstlisting}    

\begin{lstlisting}[caption=PlusTest (Schwenke),label=list:PlusTest,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.junit.Test;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import de.fhdw.wip.rpntilecalculator.model.operands.OFraction;
import de.fhdw.wip.rpntilecalculator.model.operands.OMatrix;
import de.fhdw.wip.rpntilecalculator.model.operands.OPolynom;
import de.fhdw.wip.rpntilecalculator.model.operands.OSet;
import de.fhdw.wip.rpntilecalculator.model.operands.OTuple;

import static org.junit.Assert.*;

/*
 * Summary: Test for the class 'PlusTest'
 * Author:  Tim Schwenke
 * Date:    2020/01/27
 */

public class PlusTest {

    private Plus PLUS = Plus.getInstance();

    @Test public void on_DoubleDouble_isCorrect() {
        assertTrue(PLUS.on(
                new ODouble(5),
                new ODouble(5)
                ).equalsValue(new ODouble(10)));
    }

    @Test public void on_DoubleFraction_isCorrect() {
        assertTrue(PLUS.on(
                new OFraction(2, 4),
                new OFraction(2, 4)
                ).equalsValue(new OFraction(1, 1)));
    }

    @Test public void on_FractionDouble_isCorrect() {
        assertTrue(PLUS.on(
                new OFraction(2, 2),
                new ODouble(5)
        ).equalsValue(new ODouble(6)));
    }

    @Test public void on_DoubleSet_isCorrect() {
        assertTrue(PLUS.on(
                new ODouble(1),
                new OSet(1, 2, 3)
        ).equalsValue(new OSet(2, 3, 4)));
    }

    @Test public void on_SetDouble_isCorrect() {
        assertTrue(PLUS.on(
                new OSet(1, 2, 3),
                new ODouble(1)
        ).equalsValue(new OSet(2, 3, 4)));
    }

    @Test public void on_DoubleMatrix_isCorrect() {
        assertTrue(PLUS.on(
                new ODouble(1),
                new OMatrix(new double[][]{
                        {1, 2, 3},
                        {1, 2, 3}
                })
        ).equalsValue(new OMatrix(new double[][]{
                {2, 3, 4},
                {2, 3, 4}
        })));
    }

    @Test public void on_MatrixDouble_isCorrect() {
        assertTrue(PLUS.on(
                new OMatrix(new double[][]{
                        {1, 2, 3},
                        {1, 2, 3}
                }),
                new ODouble(1)
        ).equalsValue(new OMatrix(new double[][]{
                {2, 3, 4},
                {2, 3, 4}
        })));
    }

    @Test public void on_DoublePolynom_isCorrect() {
        assertTrue(PLUS.on(
                new ODouble(1),
                new OPolynom(1, 2, 3)
        ).equalsValue(new OPolynom(2, 2, 3)));
    }

    @Test public void on_PolynomDouble_isCorrect() {
        assertTrue(PLUS.on(
                new OPolynom(1, 2, 3),
                new ODouble(1)
        ).equalsValue(new OPolynom(2, 2, 3)));
    }

    @Test public void on_DoubleTuple_isCorrect() {
        assertTrue(PLUS.on(
                new ODouble(1),
                new OTuple(1, 2, 3)
        ).equalsValue(new OTuple(2, 3, 4)));
    }

    @Test public void on_TupleDouble_isCorrect() {
        assertTrue(PLUS.on(
                new OTuple(1, 2, 3),
                new ODouble(1)
        ).equalsValue(new OTuple(2, 3, 4)));
    }

    @Test public void on_FractionFraction_isCorrect() {
        assertTrue(PLUS.on(
                new OFraction(1, 1),
                new OFraction(1, 1)
        ).equalsValue(new OFraction(2, 1)));
    }

    @Test public void on_FractionSet_isCorrect() {
        assertTrue(PLUS.on(
                new OFraction(1, 1),
                new OSet(1, 2, 3)
        ).equalsValue(new OSet(2, 3, 4)));
    }

    @Test public void on_SetFraction_isCorrect() {
        assertTrue(PLUS.on(
                new OSet(1, 2, 3),
                new OFraction(1, 1)
        ).equalsValue(new OSet(2, 3, 4)));
    }

    @Test public void on_FractionMatrix_isCorrect() {
        assertTrue(PLUS.on(
                new OFraction(1, 1),
                new OMatrix(new double[][]{
                        {1, 2, 3},
                        {1, 2, 3}
                })
        ).equalsValue(new OMatrix(new double[][]{
                {2, 3, 4},
                {2, 3, 4}
        })));
    }

    @Test public void on_MatrixFraction_isCorrect() {
        assertTrue(PLUS.on(
                new OMatrix(new double[][]{
                        {1, 2, 3},
                        {1, 2, 3}
                }),
                new OFraction(1, 1)
        ).equalsValue(new OMatrix(new double[][]{
                {2, 3, 4},
                {2, 3, 4}
        })));
    }

    @Test public void on_FractionPolynom_isCorrect() {
        assertTrue(PLUS.on(
                new OFraction(1, 1),
                new OPolynom(1, 2, 3)
        ).equalsValue(new OPolynom(2, 2, 3)));
    }

    @Test public void on_PolynomFraction_isCorrect() {
        assertTrue(PLUS.on(
                new OPolynom(1, 2, 3),
                new OFraction(1, 1)
        ).equalsValue(new OPolynom(2, 2, 3)));
    }

    @Test public void on_FractionTuple_isCorrect() {
        assertTrue(PLUS.on(
                new OFraction(1, 1),
                new OTuple(1, 2, 3)
        ).equalsValue(new OTuple(2, 3, 4)));
    }

    @Test public void on_TupleFraction_isCorrect() {
        assertTrue(PLUS.on(
                new OTuple(1, 2, 3),
                new OFraction(1, 1)
        ).equalsValue(new OTuple(2, 3, 4)));
    }

    @Test public void on_MatrixMatrix_isCorrect() {
        assertTrue(PLUS.on(
                new OMatrix(new double[][]{
                        {1, 2, 3},
                        {1, 2, 3}
                }),
                new OMatrix(new double[][]{
                        {1, 2, 3},
                        {1, 2, 3}
                })
        ).equalsValue(new OMatrix(new double[][]{
                {2, 4, 6},
                {2, 4, 6}
        })));
    }

    @Test public void on_MatrixMatrix_isWrongDimension() {
        try {
            PLUS.on(
                    new OMatrix(new double[][]{
                            {1, 2, 3},
                            {1, 2, 3}
                    }),
                    new OMatrix(new double[][]{
                            {1, 2, 3}
                    })
            );
        } catch (RuntimeException e) {
            assertTrue("Should always fail", true);
        }
    }

    @Test public void on_PolynomPolynom_isCorrect() {
        assertTrue(PLUS.on(
                new OPolynom(1, 2, 3),
                new OPolynom(0, 0, 3, 4, 5)
        ).equalsValue(new OPolynom(1, 2, 6, 4 ,5)));
    }

    @Test public void on_TupleTuple_isCorrect() {
        assertTrue(PLUS.on(
                new OTuple(1, 2, 3),
                new OTuple(1, 2, 3)
                ).equalsValue(new OTuple(2, 4, 6))
        );
    }

    @Test public void on_TupleTuple_isWrongDimension() {
        try {
            PLUS.on(
                    new OTuple(1, 2, 3),
                    new OTuple(1, 2, 3, 4)
            );
            fail();
        } catch (RuntimeException e) {
            assertTrue("Should always fail", true);
        }
    }
}
\end{lstlisting}

\begin{lstlisting}[caption=Power (Istogu),label=list:Power,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import de.fhdw.wip.rpntilecalculator.model.operands.OFraction;
import de.fhdw.wip.rpntilecalculator.model.operands.OMatrix;
import de.fhdw.wip.rpntilecalculator.model.operands.OTuple;
import de.fhdw.wip.rpntilecalculator.model.operands.Operand;

import java.lang.Math;
import java.lang.reflect.Array;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Contract;

/*
 * Summary: Defines the Power click.
 * Author:  Getuart Istogu
 * Date:    2020/01/04
 */

public class Power extends Action{

    @NotNull private static final Power POWER = new Power();
    @NotNull private static final Times TIMES = Times.getInstance();

    @Contract(pure = true) @NotNull public static Power getInstance() { return POWER; }
    private Power() {
        requiredNumOfOperands = new int[]{2};
    }

    @NotNull @Override
    public Operand with(@NotNull Operand... operands) throws CalculationException {
        scopedAction = this;
        return super.with(operands);
    }

    //region Double
    //------------------------------------------------------------------------------------

    @Contract(pure = true) @NotNull ODouble on(@NotNull ODouble base, @NotNull ODouble exponent) {
        return new ODouble(Math.pow(base.getDouble(), exponent.getDouble()));
    }

    @Contract(pure = true) @NotNull ODouble on(@NotNull ODouble base, @NotNull OFraction exponent) {
        return new ODouble(Math.pow(base.getDouble(), exponent.getDouble()));
    }

    //region Fraction
    //------------------------------------------------------------------------------------

    @Contract(pure = true) @NotNull OFraction on(@NotNull OFraction base, @NotNull ODouble exponent){
        return new OFraction(Math.pow(base.getDouble(), exponent.getDouble()));
    }

    @Contract(pure = true) @NotNull OFraction on(@NotNull OFraction base, @NotNull OFraction exponent){
        return new OFraction(Math.pow(base.getDouble(), exponent.getDouble()));
    }

    //region Matrix
    //------------------------------------------------------------------------------------

    @Contract(pure = true) @NotNull OMatrix on(@NotNull OMatrix base, @NotNull ODouble exponent) {
        if(base.getMatrix().isSquare()) {
            OMatrix resultMatrix = TIMES.on(base, base);

            if (exponent.getDouble() > 2) {
                for (int i = 2; i < exponent.getDouble(); i++)
                    resultMatrix = TIMES.on(resultMatrix, base);
            }
            return resultMatrix;
        }else
        {
            throw new IllegalArgumentException("You need a square matrix for power operation.");
        }
    }

    @Contract(pure = true) @NotNull OMatrix on(@NotNull OMatrix base, @NotNull OFraction exponent){
        return TIMES.on(TIMES.on(exponent, base), base);
    }

    //region Vector
    //------------------------------------------------------------------------------------

    @Contract(pure = true) @NotNull OTuple on(@NotNull OTuple base, @NotNull ODouble exponent) {
        double[] arrayTuple = base.getTuple();
        if(arrayTuple.length == 1)
        {
            arrayTuple[0] = Math.pow(Array.getDouble(arrayTuple,0), exponent.getDouble());
            return new OTuple(arrayTuple);
        }else
        {
            throw new IllegalArgumentException("You need a square matrix for power operation.");
        }
    }

    @Contract(pure = true) @NotNull OTuple on(@NotNull OTuple base, @NotNull OFraction exponent) {
        return on(base, new ODouble(exponent.getDouble()));
    }
}
\end{lstlisting}    

\begin{lstlisting}[caption=Sinus (Keienburg),label=list:Sinus,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import de.fhdw.wip.rpntilecalculator.model.operands.Operand;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

/*
 * Summary: Defines the Sinus action.
 * Author:  Jannis Luca Keienburg
 * Date:    2020/01/04
 */
public class Sinus extends Action {

    @NotNull
    private static final Sinus SINUS = new Sinus();

    /*
     * Singleton for SINUS
     * @return singleton object
     */
    @Contract(pure = true) @NotNull public static Sinus getInstance() { return SINUS; }
    private Sinus() {
        requiredNumOfOperands = new int[]{1, 2};
    }

    @NotNull @Override
    public Operand with(@NotNull Operand... operands) throws CalculationException {
        scopedAction = this;
        return super.with(operands);
    }

    // Calculates the sinus with a given angle.
    @Contract(pure = true) @NotNull ODouble on(@NotNull ODouble angle) {
        return new ODouble(Math.sin(Math.toRadians((angle.getDouble()))));
    }
}
\end{lstlisting}    

\begin{lstlisting}[caption=Slash (Schwenke),label=list:Slash,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import de.fhdw.wip.rpntilecalculator.model.operands.DoubleComparator;
import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import de.fhdw.wip.rpntilecalculator.model.operands.OFraction;
import de.fhdw.wip.rpntilecalculator.model.operands.OMatrix;
import de.fhdw.wip.rpntilecalculator.model.operands.OPolynom;
import de.fhdw.wip.rpntilecalculator.model.operands.OSet;
import de.fhdw.wip.rpntilecalculator.model.operands.OTuple;
import de.fhdw.wip.rpntilecalculator.model.operands.Operand;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

/*
 * Summary: Defines the Slash action.
 * Author:  Tim Schwenke
 * Date:    2020/01/04
 */
public class Slash extends Action {

    @NotNull private static final Times TIMES = Times.getInstance();
    @NotNull private static final Slash SLASH = new Slash();

    @Contract(pure = true) @NotNull public static Slash getInstance() { return SLASH; }
    private Slash() {
        requiredNumOfOperands = new int[]{2};
    }

    @NotNull @Override
    public Operand with(@NotNull Operand... operands) throws CalculationException {
        scopedAction = this;
        return super.with(operands);
    }

    //region Double
    //------------------------------------------------------------------------------------

    @Contract(pure = true) @NotNull ODouble on(@NotNull ODouble oDouble1, @NotNull ODouble oDouble2) {
        if (DoubleComparator.isZero(oDouble2.getDouble()))
            throw new IllegalArgumentException("Division by Zero not allowed");
        return new ODouble(oDouble1.getDouble() / oDouble2.getDouble());
    }

    @Contract(pure = true) @NotNull ODouble on(@NotNull ODouble oDouble, @NotNull OFraction oFraction) {
        if (DoubleComparator.isZero(oFraction.getDouble()))
            throw new IllegalArgumentException("Division by Zero not allowed");
        return new ODouble(oDouble.getDouble() / oFraction.getDouble());
    }

    //endregion

    //region Fraction
    //------------------------------------------------------------------------------------

    @Contract(pure = true) @NotNull OFraction on(@NotNull OFraction oFraction1, @NotNull OFraction oFraction2) {
        if (DoubleComparator.isZero(oFraction2.getDouble()))
            throw new IllegalArgumentException("Division by Zero not allowed");
        return new OFraction(oFraction1.getFraction().divide(oFraction2.getFraction()));
    }

    @Contract(pure = true) @NotNull ODouble on(@NotNull OFraction oFraction, @NotNull ODouble oDouble) {
        if (DoubleComparator.isZero(oDouble.getDouble()))
            throw new IllegalArgumentException("Division by Zero not allowed");
        return new ODouble(oFraction.getDouble() / oDouble.getDouble());
    }

    //endregion

    //region Set
    //------------------------------------------------------------------------------------

    @Contract(pure = true) @NotNull OSet on(@NotNull OSet oSet, @NotNull ODouble oDouble) {
        if (DoubleComparator.isZero(oDouble.getDouble()))
            throw new IllegalArgumentException("Division by Zero not allowed");
        return TIMES.on(oDouble.inverseValue(), oSet);
    }

    @Contract(pure = true) @NotNull OSet on(@NotNull OSet oSet, @NotNull OFraction oFraction) {
        if (DoubleComparator.isZero(oFraction.getDouble()))
            throw new IllegalArgumentException("Division by Zero not allowed");
        return on(oSet, new ODouble(oFraction.getDouble()));
    }

    //endregion

    //region Matrix
    //------------------------------------------------------------------------------------

    @Contract(pure = true) @NotNull OMatrix on(@NotNull OMatrix oMatrix, @NotNull ODouble oDouble) {
        if (DoubleComparator.isZero(oDouble.getDouble()))
            throw new IllegalArgumentException("Division by Zero not allowed");
        return TIMES.on(oDouble.inverseValue(), oMatrix);
    }

    @Contract(pure = true) @NotNull OMatrix on(@NotNull OMatrix oMatrix, @NotNull OFraction oFraction) {
        if (DoubleComparator.isZero(oFraction.getDouble()))
            throw new IllegalArgumentException("Division by Zero not allowed");
        return on(oMatrix, new ODouble(oFraction.getDouble()));
    }

    //endregion

    //region Polynom
    //------------------------------------------------------------------------------------

    @Contract(pure = true) @NotNull OPolynom on(@NotNull OPolynom oPolynom1, @NotNull OPolynom oPolynom2) {
        for (double d : oPolynom2.getPolynom().getCoefficients())
            if (DoubleComparator.isZero(d))
                throw new IllegalArgumentException("Division by Zero not allowed");
        return new OPolynom(oPolynom1.getPolynom().multiply(oPolynom2.inverseValue().getPolynom()));
    }

    @Contract(pure = true) @NotNull OPolynom on(@NotNull OPolynom oPolynom, @NotNull ODouble oDouble) {
        if (DoubleComparator.isZero(oDouble.getDouble()))
            throw new IllegalArgumentException("Division by Zero not allowed");
        return TIMES.on(oDouble.inverseValue(), oPolynom);
    }

    @Contract(pure = true) @NotNull OPolynom on(@NotNull OPolynom oPolynom, @NotNull OFraction oFraction) {
        if (DoubleComparator.isZero(oFraction.getDouble()))
            throw new IllegalArgumentException("Division by Zero not allowed");
        return on(oPolynom, new ODouble(oFraction.getDouble()));
    }

    //endregion

    //region Tuple
    //------------------------------------------------------------------------------------

    @Contract(pure = true) @NotNull OTuple on(@NotNull OTuple oTuple1, @NotNull OTuple oTuple2) {
        for (double d : oTuple2.getTuple())
            if (DoubleComparator.isZero(d))
                throw new IllegalArgumentException("Division by Zero not allowed");
        return TIMES.on(oTuple1, oTuple2.inverseValue());
    }

    @Contract(pure = true) @NotNull OTuple on(@NotNull OTuple oTuple, @NotNull ODouble oDouble) {
        if (DoubleComparator.isZero(oDouble.getDouble()))
            throw new IllegalArgumentException("Division by Zero not allowed");
        return TIMES.on(oDouble.inverseValue(), oTuple);
    }

    @Contract(pure = true) @NotNull OTuple on(@NotNull OTuple oTuple, @NotNull OFraction oFraction) {
        if (DoubleComparator.isZero(oFraction.getDouble()))
            throw new IllegalArgumentException("Division by Zero not allowed");
        return TIMES.on(oFraction.inverseValue(), oTuple);
    }

    //endregion
}
\end{lstlisting}    

\begin{lstlisting}[caption=SlashTest (Schwenke),label=list:SlashTest,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.junit.Test;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import de.fhdw.wip.rpntilecalculator.model.operands.OFraction;
import de.fhdw.wip.rpntilecalculator.model.operands.OMatrix;
import de.fhdw.wip.rpntilecalculator.model.operands.OPolynom;
import de.fhdw.wip.rpntilecalculator.model.operands.OSet;
import de.fhdw.wip.rpntilecalculator.model.operands.OTuple;

import static org.junit.Assert.*;

/*
 * Summary: Test for the class 'SlashTest'
 * Author:  Tim Schwenke
 * Date:    2020/01/27
 */

public class SlashTest {

    private Slash SLASH = Slash.getInstance();

    @Test public void on_DoubleDouble_isCorrect() {
        assertTrue(SLASH.on(
                new ODouble(4),
                new ODouble(2)
        ).equalsValue(new ODouble(2)));
    }

    @Test public void on_DoubleDouble_isDividedByZero() {
        try {
            SLASH.on(
                    new ODouble(4),
                    new ODouble(0)
            );
            fail();
        } catch (RuntimeException e) {
            assertTrue(true);
        }
    }

    @Test public void on_DoubleFraction_isCorrect() {
        assertTrue(SLASH.on(
                new ODouble(10),
                new OFraction(1, 2)
        ).equalsValue(new ODouble(20)));
    }

    @Test public void on_DoubleFraction_isDividedByZero() {
        try {
            SLASH.on(
                    new ODouble(4),
                    new OFraction(5, 0)
            );
            fail();
        } catch (RuntimeException e) {
            assertTrue(true);
        }
    }

    @Test public void on_FractionFraction_isCorrect() {
        assertTrue(SLASH.on(
                new OFraction(1, 2),
                new OFraction(1, 2)
        ).equalsValue(new OFraction(1, 1)));
    }

    @Test public void on_FractionDouble_isCorrect() {
        assertTrue(SLASH.on(
                new OFraction(1, 1),
                new ODouble(0.5)
        ).equalsValue(new ODouble(2)));
    }

    @Test public void on_FractionDouble_isDividedByZero() {
        try {
            SLASH.on(
                    new OFraction(1, 1),
                    new ODouble(0)
            );
            fail();
        } catch (RuntimeException e) {
            assertTrue(true);
        }
    }

    @Test public void on_SetDouble_isCorrect() {
        assertTrue(SLASH.on(
                new OSet(1, 2),
                new ODouble(2)
        ).equalsValue(new OSet(0.5, 1)));
    }

    @Test public void on_SetFraction_isCorrect() {
        assertTrue(SLASH.on(
                new OSet(1, 2),
                new OFraction(1, 2)
        ).equalsValue(new OSet(2, 4)));
    }

    @Test public void on_MatrixDouble_isCorrect() {
        assertTrue(SLASH.on(
                new OMatrix(new double[][]{
                        {1, 2},
                        {1, 2}
                }),
                new ODouble(2)
        ).equalsValue(new OMatrix(new double[][]{
                {0.5, 1},
                {0.5, 1}
        })));
    }

    @Test public void on_MatrixDouble_isDividedByZero() {
        try {
            SLASH.on(
                    new OMatrix(new double[][]{
                            {1, 2},
                            {1, 2}
                    }),
                    new ODouble(0)
            );
            fail();
        } catch (RuntimeException e) {
            assertTrue(true);
        }
    }

    @Test public void on_MatrixFraction_isCorrect() {
        assertTrue(SLASH.on(
                new OMatrix(new double[][]{
                        {1, 2},
                        {1, 2}
                }),
                new OFraction(2, 1)
        ).equalsValue(new OMatrix(new double[][]{
                {0.5, 1},
                {0.5, 1}
        })));
    }

    @Test public void on_PolynomPolynom_isCorrect() {
        assertTrue(SLASH.on(
                new OPolynom(1, 2, 3),
                new OPolynom(2, 2, 2, 2)
        ).equalsValue(new OPolynom(0.5, 1.5, 3, 3, 2.5, 1.5)));
    }

    @Test public void on_PolynomPolynom_isDividedByZero() {
        try {
            SLASH.on(
                    new OPolynom(1, 2, 3),
                    new OPolynom(0, 2, 0, 2)
            );
            fail();
        } catch (RuntimeException e) {
            assertTrue(true);
        }
    }

    @Test public void on_PolynomDouble_isCorrect() {
        assertTrue(SLASH.on(
                new OPolynom(1, 2),
                new ODouble(1)
        ).equalsValue(new OPolynom(1, 2)));
    }

    @Test public void on_PolynomFraction_isCorrect() {
        assertTrue(SLASH.on(
                new OPolynom(1, 2),
                new OFraction(1)
        ).equalsValue(new OPolynom(1, 2)));
    }

    @Test public void on_TupleTuple_isCorrect() {
        assertTrue(SLASH.on(
                new OTuple(1, 2),
                new OTuple(1, 2)
        ).equalsValue(new OTuple(1, 1)));
    }

    @Test public void on_TupleDouble_isCorrect() {
        assertTrue(SLASH.on(
                new OTuple(1, 2),
                new OTuple(2, 2)
        ).equalsValue(new OTuple(0.5, 1)));
    }

    @Test public void on_TupleFraction_isCorrect() {
        assertTrue(SLASH.on(
                new OTuple(1, 2),
                new OFraction(1, 1)
        ).equalsValue(new OTuple(1, 2)));
    }
}
\end{lstlisting}

\begin{lstlisting}[caption=Tangens (Keienburg),label=list:Tangens,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import de.fhdw.wip.rpntilecalculator.model.operands.Operand;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

/*
 * Summary: Defines the Tangens action.
 * Author:  Jannis Luca Keienburg
 * Date:    2020/01/04
 */
public class Tangens extends Action {

    @NotNull
    private static final Tangens TANGENS = new Tangens();

    /*
     * Singleton for SINUS
     * @return singleton object
     */
    @Contract(pure = true) @NotNull public static Tangens getInstance() { return TANGENS; }
    private Tangens() {
        requiredNumOfOperands = new int[]{1,2};
    }

    @NotNull @Override
    public Operand with(@NotNull Operand... operands) throws CalculationException {
        scopedAction = this;
        return super.with(operands);
    }

    // Calculates the tangens with a given angle.
    @Contract(pure = true) @NotNull ODouble on(@NotNull ODouble angle) {
        return new ODouble(Math.tan(Math.toRadians((angle.getDouble()))));
    }
}
\end{lstlisting}    

\begin{lstlisting}[caption=Times (Schwenke),label=list:Times,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import de.fhdw.wip.rpntilecalculator.model.operands.OFraction;
import de.fhdw.wip.rpntilecalculator.model.operands.OMatrix;
import de.fhdw.wip.rpntilecalculator.model.operands.OPolynom;
import de.fhdw.wip.rpntilecalculator.model.operands.OSet;
import de.fhdw.wip.rpntilecalculator.model.operands.OTuple;
import de.fhdw.wip.rpntilecalculator.model.operands.Operand;

import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import java.util.HashSet;
import java.util.Set;

/*
 * Summary: Defines the Times click. Lets the user Multiplies operands.
 * Author:  Tim Schwenke
 * Date:    2020/01/04
 */
@SuppressWarnings({"unused"})
public class Times extends Action {

    @NotNull private static final Times TIMES = new Times();

    /*
     * Singleton for TIMES
     * @return singleton object
     */
    @Contract(pure = true) @NotNull public static Times getInstance() { return TIMES; }
    private Times() {
        requiredNumOfOperands = new int[]{2};
    }

    /*
     * Multiplying ODouble and ODouble
     * @param operands params
     * @return product of operands
     */
    @NotNull @Override
    public Operand with(@NotNull Operand... operands) throws CalculationException {
        scopedAction = this;
        return super.with(operands);
    }

    //region Double
    //------------------------------------------------------------------------------------

    /*
     * Multiplying ODouble and ODouble
     * @param oDouble1 first operand
     * @param oDouble2 second operand
     * @return product of params
     */
    @Contract(pure = true) @NotNull ODouble on(@NotNull ODouble oDouble1, @NotNull ODouble oDouble2) {
        return new ODouble(oDouble1.getDouble() * oDouble2.getDouble());
    }

    /*
     * Multiplying ODouble and oFraction
     * @param oDouble first operand
     * @param oFraction second operand
     * @return product of params
     */
    @Contract(pure = true) @NotNull ODouble on(@NotNull ODouble oDouble, @NotNull OFraction oFraction) {
        return new ODouble(oDouble.getDouble() * oFraction.getDouble());
    }

    @Contract(pure = true) @NotNull ODouble on(@NotNull OFraction oFraction, @NotNull ODouble oDouble) {
        return on(oDouble, oFraction);
    }

    // endregion

    //region OSet
    //------------------------------------------------------------------------------------

    /*
     * Multiplying ODouble and oSet
     * @param oDouble first operand
     * @param oSet second operand
     * @return product of params
     */
    @Contract(pure = true) @NotNull OSet on(@NotNull ODouble oDouble, @NotNull OSet oSet) {
        Set<Double> newSet = new HashSet<>();
        for (double d : oSet.getSet())
            newSet.add(d * oDouble.getDouble());
        return new OSet(newSet);
    }

    @Contract(pure = true) @NotNull OSet on(@NotNull OSet oSet, @NotNull ODouble oDouble) {
        return on(oDouble, oSet);
    }

    /*
     * Multiplying ODouble and oMatrix
     * @param oDouble first operand
     * @param oMatrix second operand
     * @return product of params
     */
    @Contract(pure = true) @NotNull OMatrix on(@NotNull ODouble oDouble, @NotNull OMatrix oMatrix) {
        return new OMatrix(oMatrix.getMatrix().scalarMultiply(oDouble.getDouble()));
    }

    @Contract(pure = true) @NotNull OMatrix on(@NotNull OMatrix oMatrix, @NotNull ODouble oDouble) {
        return on(oDouble, oMatrix);
    }

    /*
     * Multiplying ODouble and oPolynom
     * @param oDouble first operand
     * @param oPolynom second operand
     * @return product of params
     */
    @Contract(pure = true) @NotNull OPolynom on(@NotNull ODouble oDouble, @NotNull OPolynom oPolynom) {
        double[] d = oPolynom.getPolynom().getCoefficients();
        for (int i = 0; i < d.length; i++)
            d[i] *= oDouble.getDouble();
        return new OPolynom(new PolynomialFunction(d));
    }

    @Contract(pure = true) @NotNull OPolynom on(@NotNull OPolynom oPolynom, @NotNull ODouble oDouble) {
        return on(oDouble, oPolynom);
    }

    /*
     * Multiplying ODouble and oTuple
     * @param oDouble first operand
     * @param oTuple second operand
     * @return product of params
     */
    @Contract(pure = true) @NotNull OTuple on(@NotNull ODouble oDouble, @NotNull OTuple oTuple) {
        double[] oldTuple = oTuple.getTuple();
        double[] newTuple = new double[oldTuple.length];
        for (int i = 0; i < newTuple.length; i++)
            newTuple[i] = oldTuple[i] * oDouble.getDouble();
        return new OTuple(newTuple);
    }

    @Contract(pure = true) @NotNull OTuple on(@NotNull OTuple oTuple, @NotNull ODouble oDouble) {
        return on(oDouble, oTuple);
    }

    //endregion

    //region Fraction
    //------------------------------------------------------------------------------------

    /*
     * Multiplying OFraction and OFraction
     * @param oFraction1 first operand
     * @param oFraction2 second operand
     * @return product of params
     */
    @Contract(pure = true) @NotNull OFraction on(@NotNull OFraction oFraction1, @NotNull OFraction oFraction2) {
        return new OFraction(oFraction1.getFraction().multiply(oFraction2.getFraction()));
    }

    /*
     * Multiplying OFraction and OSet
     * @param oFraction first operand
     * @param oSet second operand
     * @return product of params
     */
    @Contract(pure = true) @NotNull OSet on(@NotNull OFraction oFraction, @NotNull OSet oSet) {
        return on(new ODouble(oFraction.getDouble()), oSet);
    }

    /*
     * Multiplying OFraction and OMatrix
     * @param oFraction first operand
     * @param oMatrix second operand
     * @return product of params
     */
    @Contract(pure = true) @NotNull OMatrix on(@NotNull OFraction oFraction, @NotNull OMatrix oMatrix) {
        return new OMatrix(oMatrix.getMatrix().scalarMultiply(oFraction.getDouble()));
    }

    @Contract(pure = true) @NotNull OMatrix on(@NotNull OMatrix oMatrix, @NotNull OFraction oFraction) {
        return on(oFraction, oMatrix);
    }

    /*
     * Multiplying OFraction and oPolynom
     * @param oFraction first operand
     * @param oPolynom second operand
     * @return product of params
     */
    @Contract(pure = true) @NotNull OPolynom on(@NotNull OFraction oFraction, @NotNull OPolynom oPolynom) {
        return on(new ODouble(oFraction.getDouble()), oPolynom);
    }

    /*
     * Multiplying OFraction and oTuple
     * @param oFraction first operand
     * @param oTuple second operand
     * @return product of params
     */
    @Contract(pure = true) @NotNull OTuple on(@NotNull OFraction oFraction, @NotNull OTuple oTuple) {
        return on(new ODouble(oFraction.getDouble()), oTuple);
    }

    //endregion

    /*
     * Multiplying OMatrix and OMatrix
     * @param oMatrix1 first operand
     * @param oMatrix2 second operand
     * @return product of params
     */
    @Contract(pure = true) @NotNull OMatrix on(@NotNull OMatrix oMatrix1, @NotNull OMatrix oMatrix2) {
        return new OMatrix(oMatrix1.getMatrix().multiply(oMatrix2.getMatrix()));
    }

    /*
     * Multiplying OPolynom and OPolynom
     * @param oPolynom1 first operand
     * @param oPolynom2 second operand
     * @return product of params
     */
    @Contract(pure = true) @NotNull OPolynom on(@NotNull OPolynom oPolynom1, @NotNull OPolynom oPolynom2) {
        return new OPolynom(oPolynom1.getPolynom().multiply(oPolynom2.getPolynom()));
    }

    /*
     * Multiplying OTuple and OTuple
     * @param oTuple1 first operand
     * @param oTuple2 second operand
     * @return product of params
     */
    @Contract(pure = true) @NotNull OTuple on(@NotNull OTuple oTuple1, @NotNull OTuple oTuple2) {
        double[] tuple1 = oTuple1.getTuple();
        double[] tuple2 = oTuple2.getTuple();
        double[] tupleSum = new double[tuple2.length];

        if (tuple1.length != tuple2.length)
            throw new IllegalArgumentException("Tuples must have matching size.");

        for (int i = 0; i < tuple1.length; i++)
            tupleSum[i] = tuple1[i] * tuple2[i];

        return new OTuple(tupleSum);
    }

}
\end{lstlisting}    

\begin{lstlisting}[caption=TimesTest (Schwenke),label=list:TimesTest,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.junit.Test;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import de.fhdw.wip.rpntilecalculator.model.operands.OFraction;
import de.fhdw.wip.rpntilecalculator.model.operands.OMatrix;
import de.fhdw.wip.rpntilecalculator.model.operands.OPolynom;
import de.fhdw.wip.rpntilecalculator.model.operands.OSet;
import de.fhdw.wip.rpntilecalculator.model.operands.OTuple;

import static org.junit.Assert.*;

/*
 * Summary: Test for the class 'TimesTest'
 * Author:  Tim Schwenke
 * Date:    2020/01/27
 */

public class TimesTest {

    private Times TIMES = Times.getInstance();

    @Test public void on_DoubleDouble_isCorrect() {
        assertTrue(TIMES.on(
                        new ODouble(5),
                        new ODouble(5)
        ).equalsValue(new ODouble(25)));
    }

    @Test public void on_DoubleFraction_isCorrect() {
        assertTrue(TIMES.on(
                new ODouble(5),
                new OFraction(5, 1)
        ).equalsValue(new ODouble(25)));
    }

    @Test public void on_FractionDouble_isCorrect() {
        assertTrue(TIMES.on(
                new OFraction(1, 1),
                new ODouble(5)
        ).equalsValue(new ODouble(5)));
    }

    @Test public void on_DoubleSet_isCorrect() {
        assertTrue(TIMES.on(
                new ODouble(2),
                new OSet(1, 2)
        ).equalsValue(new OSet(2, 4)));
    }

    @Test public void on_SetDouble_isCorrect() {
        assertTrue(TIMES.on(
                new OSet(1, 2),
                new ODouble(2)
        ).equalsValue(new OSet(2, 4)));
    }

    @Test public void on_DoubleMatrix_isCorrect() {
        assertTrue(TIMES.on(
                new ODouble(2),
                new OMatrix(new double[][]{{1, 2}})
        ).equalsValue(new OMatrix(new double[][]{{2, 4}})));
    }

    @Test public void on_MatrixDouble_isCorrect() {
        assertTrue(TIMES.on(
                new OMatrix(new double[][]{{1, 2}}),
                new ODouble(2)
        ).equalsValue(new OMatrix(new double[][]{{2, 4}})));
    }

    @Test public void on_DoublePolynom_isCorrect() {
        assertTrue(TIMES.on(
                new ODouble(2),
                new OPolynom(0, 1, 2)
        ).equalsValue(new OPolynom(0, 2, 4)));
    }

    @Test public void on_PolynomDouble_isCorrect() {
        assertTrue(TIMES.on(
                new OPolynom(0, 1, 2),
                new ODouble(2)
        ).equalsValue(new OPolynom(0, 2, 4)));
    }

    @Test public void on_DoubleTuple_isCorrect() {
        assertTrue(TIMES.on(
                new ODouble(2),
                new OTuple(1, 2)
        ).equalsValue(new OTuple(2, 4)));
    }

    @Test public void on_TupleDouble_isCorrect() {
        assertTrue(TIMES.on(
                new OTuple(1, 2),
                new ODouble(2)
        ).equalsValue(new OTuple(2, 4)));
    }

    @Test public void on_FractionFraction_isCorrect() {
        assertTrue(TIMES.on(
                new OFraction(2, 1),
                new OFraction(2, 1)
        ).equalsValue(new OFraction(4, 1)));
    }

    @Test public void on_FractionSet_isCorrect() {
        assertTrue(TIMES.on(
                new OFraction(1, 1),
                new OSet(1, 2)
        ).equalsValue(new OSet(1, 2)));
    }

    @Test public void on_FractionMatrix_isCorrect() {
        assertTrue(TIMES.on(
                new OFraction(1, 1),
                new OMatrix(new double[][]{
                        {1, 2},
                        {1, 2}
                })
        ).equalsValue(new OMatrix(new double[][]{
                {1, 2},
                {1, 2}
        })));
    }

    @Test public void on_FractionPolynom_isCorrect() {
        assertTrue(TIMES.on(
                new OFraction(1, 1),
                new OPolynom(0, 1, 3)
        ).equalsValue(new OPolynom(0, 1, 3)));
    }

    @Test public void on_FractionTuple_isCorrect() {
        assertTrue(TIMES.on(
                new OFraction(1, 1),
                new OTuple(1, 2)
        ).equalsValue(new OTuple(1, 2)));
    }

    @Test public void on_MatrixMatrix_isCorrect() {
        assertTrue(TIMES.on(
                new OMatrix(new double[][]{
                        {1, 2},
                        {1, 2}
                }),
                new OMatrix(new double[][]{
                        {1, 2},
                        {1, 2}
                })
        ).equalsValue(new OMatrix(new double[][]{
                {3, 6},
                {3, 6}
        })));
    }

    @Test public void on_PolynomPolynom_isCorrect() {
        assertTrue(TIMES.on(
                new OPolynom(1, 2),
                new OPolynom(2, 3)
        ).equalsValue(new OPolynom(2, 7, 6)));
    }

    @Test public void on_TupleTuple_isCorrect() {
        assertTrue(TIMES.on(
                new OTuple(1, 2),
                new OTuple(1, 2)
        ).equalsValue(new OTuple(1, 4)));
    }
}
\end{lstlisting}

\begin{lstlisting}[caption=Zeros (Keienburg),label=list:Zeros,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import de.fhdw.wip.rpntilecalculator.model.operands.OPolynom;
import de.fhdw.wip.rpntilecalculator.model.operands.OTuple;
import de.fhdw.wip.rpntilecalculator.model.operands.Operand;

/*
 * Summary: A Class that can calculate the zeros of functions and quadratic functions.
 * Author:  Jannis Luca Keienburg
 * Date:    2020/01/15
 */
public class Zeros extends Action {

    @NotNull private static final Zeros ZEROS = new Zeros();

    @Contract(pure = true) @NotNull public static Zeros getInstance() { return ZEROS; }
    private Zeros() {requiredNumOfOperands = new int[] {1}; }

    @NotNull @Override
    public Operand with(@NotNull Operand... operands) throws CalculationException {
        scopedAction = this;
        return super.with(operands);
    }

    @Contract(pure = true) @NotNull OTuple on(@NotNull OPolynom oPolynom) {
        double[] results = calculateZeros(oPolynom);
        return new OTuple(results);
    }

    // Function that calculates the zeros when called
    public double [] calculateZeros(OPolynom oPolynom)
    {
        double [] zeros = new double[] {};
        double[] functionAsDouble = oPolynom.getPolynom().getCoefficients();
        int type = normalOrQuadraticFunction(functionAsDouble);
        if (type == 1)
        {
            zeros = zerosTypeOne(functionAsDouble);
        }
        else if(type == 2)
        {
            zeros = zerosTypeTwo(functionAsDouble);
        }
        return zeros;
    }

    // Checks if it is a normal function or an quadratic funtion
    private int normalOrQuadraticFunction(double [] functionAsDouble)
    {
        int result = 1;
        if(functionAsDouble.length == 3)
        {
            result = 2;
        }
        return result;
    }

    // Calculates the zeros for functions like:
    // a * x + b = 0
    private double[] zerosTypeOne(double [] functionAsDouble)
    {
        double [] zeros = new double[1];
        zeros[0] = (functionAsDouble[1] * (-1)) / functionAsDouble[0];
        return zeros;
    }

    // Calculates the zeros for functions like:
    // a * x^2 + b * x + c = 0
    // uses the Mitternachtsformel
    private double[] zerosTypeTwo(double [] functionAsDouble)
    {
        double [] zeros = new double[2];
        zeros[0] = -functionAsDouble[1]
                - Math.sqrt(((functionAsDouble[1] * functionAsDouble[1]) - (4 * functionAsDouble[0] * functionAsDouble[2])) )
                / (2 * functionAsDouble[0]);
        zeros[1] = -functionAsDouble[1]
                + Math.sqrt(((functionAsDouble[1] * functionAsDouble[1]) - (4 * functionAsDouble[0] * functionAsDouble[2])) )
                / (2 * functionAsDouble[0]);
        return zeros;
    }
}
\end{lstlisting}    

\begin{lstlisting}[caption=Root (Istogu),label=list:Root,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import de.fhdw.wip.rpntilecalculator.model.operands.OFraction;
import de.fhdw.wip.rpntilecalculator.model.operands.OMatrix;
import de.fhdw.wip.rpntilecalculator.model.operands.Operand;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Contract;

/*
 * Summary: Defines the Root click.
 * Author:  Getuart Istogu
 * Date:    2020/01/04
 */

public class Root extends Action{
    @NotNull private static final Root ROOT = new Root();
    @NotNull private static final Power POWER = Power.getInstance();

    @Contract(pure = true) @NotNull public static Root getInstance() { return ROOT; }
    private Root() {
        requiredNumOfOperands = new int[]{2};
    }

    @NotNull @Override
    public Operand with(@NotNull Operand... operands) throws CalculationException {
        scopedAction = this;
        return super.with(operands);
    }

    //region Double
    //------------------------------------------------------------------------------------

    @Contract(pure = true) @NotNull ODouble on(@NotNull ODouble radicand, @NotNull ODouble exponent) {
        return POWER.on(radicand, new ODouble(1/exponent.getDouble()));
    }

    @Contract(pure = true) @NotNull ODouble on(@NotNull ODouble radicand, @NotNull OFraction exponent){
        return POWER.on(radicand, new OFraction(1/exponent.getDouble()));
    }

    //region Fraction
    //------------------------------------------------------------------------------------
    @Contract(pure = true) @NotNull OFraction on(@NotNull OFraction radicand, @NotNull ODouble exponent){
        return POWER.on(radicand, new OFraction(1/exponent.getDouble()));
    }

    @Contract(pure = true) @NotNull OFraction on(@NotNull OFraction radicand, @NotNull OFraction exponent){
        return POWER.on(radicand, new ODouble(1/exponent.getDouble()));
    }

    //region Matrix
    //------------------------------------------------------------------------------------
    @Contract(pure = true) @NotNull OMatrix on(@NotNull OMatrix radicand, @NotNull ODouble exponent) {
        return POWER.on(radicand, new ODouble(1/exponent.getDouble()));
    }

    @Contract(pure = true) @NotNull OMatrix on(@NotNull OMatrix radicand, @NotNull OFraction exponent) {
        return POWER.on(radicand, new ODouble(1/exponent.getDouble()));
    }
}

\end{lstlisting}    

\begin{lstlisting}[caption=RootTest (Pham),label=list:RootTest,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.junit.Test;
import static org.junit.Assert.*;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import de.fhdw.wip.rpntilecalculator.model.operands.OFraction;

/*
 * Summary: Test for the class 'RootTest'
 * Author:  Khang Pham
 * Date:    2020/01/27
 */
public class RootTest {

    private Root ROOT = Root.getInstance();

    //region Double
    @Test public void onDoubleDouble_isCorrect() {
        assertTrue(ROOT.on(
                new ODouble(36),
                new ODouble(2)
                ).equalsValue(new ODouble((6))));
    }

    @Test public void onDoubleFraction_isCorrect() {
        assertTrue(ROOT.on(
                new ODouble(36),
                new OFraction(0.5)
        ).equalsValue(new ODouble((1296))));
    }
}
\end{lstlisting}

\subsubsection{Operands}

\begin{lstlisting}[caption=DoubleComparator (Schwenke),label=list:DoubleComparator,language=Java]
package de.fhdw.wip.rpntilecalculator.model.operands;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import java.util.Arrays;
import java.util.Set;

/*
 * Summary: Utility to compare Doubles.
 * Author:  Tim Schwenke
 * Date:    2020/01/08
 */
public class DoubleComparator {

    /**
     * Check if two doubles are equal (with a certain margin).
     * @param d1 First double
     * @param d2 Second double
     * @return Boolean
     */
    @Contract(pure = true) public static boolean isEqual(double d1, double d2) {
        return Math.abs(d1 - d2) < 0.000001;
    }

    /**
     * Compares two arrays of Double.
     * @param d1 First double array.
     * @param d2 Second double array
     * @return Boolean
     */
    @Contract(pure = true) public static boolean isEqual(
            @NotNull double[] d1,
            @NotNull double[] d2
    ) {
        if (d1.length != d2.length) return false;
        if (Arrays.equals(d1, d2)) return true;

        for (int i = 0; i < d1.length; i++)
            if (!isEqual(d1[i], d2[i])) return false;

        return true;
    }

    /**
     * Compares two matrices of doubles for equality.
     * @param d1 First matrix
     * @param d2 Second matrix
     * @return Boolean
     */
    @Contract(pure = true) public static boolean isEqual(
            @NotNull double[][] d1,
            @NotNull double[][] d2
    ) {
        if (d1.length != d2.length) return false;
        for (int i = 0; i < d1.length; i++)
            if (d1[i].length != d2[i].length) return false;

        for (int i = 0; i < d1.length; i++)
            if (!isEqual(d1[i], d2[i])) return false;

        return true;
    }

    /**
     * Compares two sets of Doubles for equality.
     * @param d1 First set
     * @param d2 Second set
     * @return Boolean
     */
    @Contract(pure = true) public static boolean isEqual(
            @NotNull Set<Double> d1,
            @NotNull Set<Double> d2
    ) {
        Double[] d1Array = new Double[d1.size()];
        d1.toArray(d1Array);

        Double[] d2Array = new Double[d2.size()];
        d2.toArray(d2Array);

        double[] d1ArrayPrim = new double[d1.size()];
        for (int i = 0; i < d1.size(); i++) d1ArrayPrim[i] = d1Array[i];

        double[] d2ArrayPrim = new double[d2.size()];
        for (int i = 0; i < d1.size(); i++) d2ArrayPrim[i] = d2Array[i];

        return isEqual(d1ArrayPrim, d2ArrayPrim);
    }

    /**
     * Check if double is about zero (margin).
     * @param d Double to check
     * @return Boolean
     */
    @Contract(pure = true) public static boolean isZero(double d) {
        double delta = 0.00001;
        return d < delta && d > -1d * delta;
    }

}
\end{lstlisting}    

\begin{lstlisting}[caption=DoubleFormatter (Schwenke),label=list:DoubleFormatter,language=Java]
package de.fhdw.wip.rpntilecalculator.model.operands;

import org.jetbrains.annotations.NotNull;

import java.text.DecimalFormat;

/*
 * Summary: Util for formatting all Double Values
 * Author:  Tim Schwenke
 * Date:    2020/01/04
 */
public final class DoubleFormatter {

    // Decimal Format
    private static final DecimalFormat DF = new DecimalFormat("#.##");

    /*
     * Format the given double in the format to a string
     * @param d the double that is to be formatted
     * @return the formatted string
     */
    @NotNull public static String format(double d) {
        return DF.format(d);
    }

}

\end{lstlisting} 

\begin{lstlisting}[caption=Element (Schwenke),label=list:Element,language=Java]
package de.fhdw.wip.rpntilecalculator.model.operands;

/*
 * Summary: Main Element Wrapper for all kinds
 * Author:  Tim Schwenke
 * Date:    2020/01/04
 */
public abstract class Element {

}
\end{lstlisting}    

\begin{lstlisting}[caption=ODouble (Schwenke),label=list:ODouble,language=Java]
package de.fhdw.wip.rpntilecalculator.model.operands;

import org.apache.commons.math3.primes.Primes;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

/*
 * Summary: Wrapper for the Double Operand
 * Author:  Tim Schwenke
 * Date:    2020/01/04
 */
public class ODouble extends Operand {

    // content to be wrapped
    private double aDouble;

    /*
     * Create a new ODouble from a double
     * @param aDouble content to be wrapped
     */
    public ODouble(double aDouble) {
        this.aDouble = aDouble;
    }

    /*
     * Create a new ODouble from a string
     * @param aDouble content to be wrapped
     */
    public ODouble(String aDouble) { this.aDouble = Double.valueOf(aDouble); }

    /*
     * Get the underlying content
     * @return the underlying content
     */
    public double getDouble() {
        return aDouble;
    }

    /*
     * swap the pre Sign (+ -> -; - -> +)
     * @return new double
     */
    @NotNull @Override public ODouble turnAroundSign() {
        return new ODouble(aDouble * -1);
    }

    /*
     * Turn the pre Sign to negative
     * @return new double
     */
    @NotNull @Override public ODouble negateValue() {
        return new ODouble(Math.abs(aDouble) * -1);
    }

    /*
     * Inverse the value
     * @return new double
     */
    @NotNull @Override public ODouble inverseValue() {
        return new ODouble(1 / aDouble);
    }

    /*
     * Format the double to a string
     * @return String representation of the content
     */
    @NotNull @Override public String toString() {
        return DoubleFormatter.format(aDouble);
    }

    @Override public boolean equalsValue(@Nullable Operand operand) {
        if (operand == this) return true;
        if (!(operand instanceof ODouble)) return false;

        double bDouble = ((ODouble) operand).getDouble();

        return DoubleComparator.isEqual(aDouble, bDouble);
    }

    /*
    If number has a decimal part it returns false
     */
    public boolean isPrime()
    {
        if(this.aDouble % 1 == 0)
        {
            return Primes.isPrime((int) this.aDouble);
        }
        else
        {
            return false;
        }
    }
}
\end{lstlisting}    

\begin{lstlisting}[caption=OEmpty (Meinerzhagen),label=list:OEmpty,language=Java]
package de.fhdw.wip.rpntilecalculator.model.operands;

import org.apache.commons.math3.primes.Primes;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

/*
 * Summary: Wrapper for the Double Operand
 * Author:  Tim Jonas Meinerzhagen
 * Date:    2020/01/04
 */
public class OEmpty extends Operand {

    /*
     * Create a an empty operand
     * @param aDouble content to be wrapped
     */
    public OEmpty() { }



    /*
     * Create a an empty operand
     * @param aDouble content to be wrapped
     */
    public OEmpty(String content) { }


    /*
     * swap the pre Sign
     * @return new empty
     */
    @NotNull @Override public OEmpty turnAroundSign() { return this; }

    /*
     * Turn the pre Sign to negative
     * @return new empty
     */
    @NotNull @Override public OEmpty negateValue()  { return this; }

    /*
     * Inverse the value
     * @return new empty
     */
    @NotNull @Override public OEmpty inverseValue()  { return this; }

    /*
     * Format the empty to a string
     * @return String representation of the content
     */
    @NotNull @Override public String toString() { return " "; }

    @Override public boolean equalsValue(@Nullable Operand operand) {
        if (operand == this) return true;
        return operand instanceof OEmpty;
    }
}
\end{lstlisting}    

\begin{lstlisting}[caption=OFraction (Schwenke),label=list:OFraction,language=Java]
package de.fhdw.wip.rpntilecalculator.model.operands;

import org.apache.commons.math3.fraction.Fraction;
import org.apache.commons.math3.primes.Primes;
import org.jetbrains.annotations.NotNull;

/*
 * Summary: Wrapper for the Fraction Operand
 * Author:  Tim Schwenke
 * Date:    2020/01/04
 */
public class OFraction extends Operand {

    @NotNull private Fraction fraction;

    public OFraction(@NotNull Fraction fraction) {
        this.fraction = fraction;
    }

    public OFraction(int nom, int den) {
        this.fraction = new Fraction(nom, den);
    }

    public OFraction(@NotNull double doubleValue) {this.fraction = new Fraction(doubleValue); }

    public OFraction(@NotNull String fraction) {
        String[] vars = fraction.split("[(/)]");
        int nom = Integer.valueOf(vars[1]);
        int den = Integer.valueOf(vars[2]);
        this.fraction = new Fraction(nom, den);
    }

    public @NotNull Fraction getFraction() {
        return fraction;
    }

    public double getDouble() {
        return fraction.doubleValue();
    }

    @NotNull @Override public OFraction turnAroundSign() {
        return new OFraction(fraction.multiply(-1));
    }

    @NotNull @Override public OFraction negateValue() {
        return new OFraction(new Fraction(
                Math.abs(fraction.getNumerator()) * -1,
                Math.abs(fraction.getDenominator()) * -1
        ));
    }

    @Override public @NotNull OFraction inverseValue() {
        return new OFraction(fraction.reciprocal());
    }

    @Override
    public boolean equalsValue(Operand operand) {
        if (operand == this) return true;
        if (!(operand instanceof OFraction)) return false;

        return ((OFraction) operand).getFraction().compareTo(fraction) == 0;
    }

    @NotNull @Override public String toString() {
        return String.format("(%s/%s)",
                DoubleFormatter.format(fraction.getNumerator()),
                DoubleFormatter.format(fraction.getDenominator())
        );
    }

    /*
    If number has a decimal part it returns false
    For the case if the Fraction is natural number
     */
    public boolean isPrime()
    {
        double doubleValue = getDouble();
        if(doubleValue % 1 == 0)
        {
            return Primes.isPrime((int) doubleValue);
        }
        else
        {
            return false;
        }
    }
}
\end{lstlisting}    

\begin{lstlisting}[caption=OMatrix (Schwenke),label=list:OMatrix,language=Java]
package de.fhdw.wip.rpntilecalculator.model.operands;

import org.apache.commons.math3.linear.Array2DRowRealMatrix;
import org.apache.commons.math3.linear.MatrixUtils;
import org.apache.commons.math3.linear.RealMatrix;
import org.jetbrains.annotations.NotNull;

import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/*
 * Summary: Wrapper for the Matrix Operand
 * Author:  Tim Schwenke
 * Date:    2020/01/04
 */
@SuppressWarnings("unused")
public class OMatrix extends Operand {

    @NotNull private RealMatrix matrix;

    public OMatrix(@NotNull RealMatrix matrix) {
        this.matrix = matrix;
    }

    public OMatrix(@NotNull double[][] doubleMatrix) {
        int longest = 0;

        for (double[] dim1 : doubleMatrix)
            if (dim1.length > longest) longest = dim1.length;

        double[][] modified = new double[doubleMatrix.length][longest];
        for (int i = 0; i < doubleMatrix.length; i++)
            System.arraycopy(
                    doubleMatrix[i], 0,
                    modified[i], 0, doubleMatrix[i].length
            );

        matrix = new Array2DRowRealMatrix(modified);
    }

    public OMatrix(@NotNull String matrix) {
        //[[1.23, 1.32], [0.23, 1.23]]
        ArrayList<double[]> listMatrix = new ArrayList<>();
        Pattern pat1 = Pattern.compile("\\[[^\\[\\]].*?\\]");
        Matcher mat1 = pat1.matcher(matrix);

        while(mat1.find()) {
            String row = matrix.substring(mat1.start(), mat1.end());

            ArrayList<Double> listArray = new ArrayList<>();
            pat1 = Pattern.compile("[\\-0-9.]+");
            Matcher mat2 = pat1.matcher(row);

            while(mat2.find()) {
                String value = row.substring(mat2.start(), mat2.end());
                listArray.add(Double.valueOf(value));
            }

            double[] doubleArray = new double[listArray.size()];
            for(int i = 0; i < listArray.size(); i++) doubleArray[i] = listArray.get(i);
            listMatrix.add(doubleArray);
        }
        double[][] doubleMatrix = new double[listMatrix.size()][];
        for(int i = 0; i < listMatrix.size(); i++) doubleMatrix[i] = listMatrix.get(i);
        this.matrix = new Array2DRowRealMatrix(doubleMatrix);
    }

    public @NotNull RealMatrix getMatrix() {
        return matrix;
    }

    @NotNull @Override public OMatrix turnAroundSign() {
        return new OMatrix(matrix.scalarMultiply(-1));
    }

    @NotNull @Override public OMatrix negateValue() {
        double[][] dim1 = matrix.getData();
        for (int i = 0; i < dim1.length; i++)
            for (int k = 0; k < dim1[i].length; k++)
                dim1[i][k] = Math.abs(dim1[i][k]) * -1;
        return new OMatrix(new Array2DRowRealMatrix(dim1));
    }

    @Override public @NotNull OMatrix inverseValue() {
        return new OMatrix(MatrixUtils.inverse(matrix));
    }

    @Override
    public boolean equalsValue(Operand operand) {
        if (operand == this) return true;
        if (!(operand instanceof OMatrix)) return false;

        return DoubleComparator.isEqual(
                matrix.getData(),
                ((OMatrix) operand).getMatrix().getData()
        );
    }

    @NotNull @Override public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("[");
        for (double[] doubles : matrix.getData()) {
            builder.append("[");
            for (double d : doubles) {
                builder.append(DoubleFormatter.format(d));
                builder.append(", ");
            }
            builder.delete(builder.length() - 2, builder.length());
            builder.append("], ");
        }
        builder.delete(builder.length() - 2, builder.length());
        builder.append("]");
        return builder.toString();
    }
}
\end{lstlisting}    

\begin{lstlisting}[caption=OPolynom (Schwenke),label=list:OPolynom,language=Java]
package de.fhdw.wip.rpntilecalculator.model.operands;

import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;
import org.jetbrains.annotations.NotNull;

import java.util.ArrayList;

/*
 * Summary: Wrapper for the Polynom Operand
 * Author:  Tim Schwenke
 * Date:    2020/01/04
 */
public class OPolynom extends Operand {

    @NotNull private PolynomialFunction polynom;

    public OPolynom(@NotNull PolynomialFunction polynom) {
        this.polynom = polynom;
    }

    public OPolynom(@NotNull double... coefficients) {
        this.polynom = new PolynomialFunction(coefficients);
    }

    public OPolynom(@NotNull String polynom) {
        //4.1x^0 + 2x^1 + -3.1x^2
        String[] vars = polynom.trim().split("(x\\^[0-9])( \\+)*");
        double[] coefficients = new double[vars.length];
        for(int i = 0; i < vars.length; i++) coefficients[i] = Double.valueOf(vars[i].trim());
        this.polynom = new PolynomialFunction(coefficients);
    }

    public @NotNull PolynomialFunction getPolynom() {
        return polynom;
    }

    @NotNull @Override public OPolynom turnAroundSign() {
        double[] doubles = polynom.getCoefficients();
        for (int i = 0; i < doubles.length; i++)
            doubles[i] *= -1;
        return new OPolynom(new PolynomialFunction(doubles));
    }

    @NotNull @Override public OPolynom negateValue() {
        double[] doubles = polynom.getCoefficients();
        for (int i = 0; i < doubles.length; i++)
            doubles[i] = Math.abs(doubles[i]) * -1;
        return new OPolynom(new PolynomialFunction(doubles));
    }

    @Override public @NotNull OPolynom inverseValue() {
        double[] doubles = polynom.getCoefficients();
        for (int i = 0; i < doubles.length; i++)
            doubles[i] = 1 / doubles[i];
        return new OPolynom(new PolynomialFunction(doubles));
    }

    @Override
    public boolean equalsValue(Operand operand) {
        if (operand == this) return true;
        if (!(operand instanceof OPolynom)) return false;

        return DoubleComparator.isEqual(
                polynom.getCoefficients(),
                ((OPolynom) operand).getPolynom().getCoefficients()
        );
    }

    @NotNull @Override public String toString() {
        StringBuilder builder = new StringBuilder();
        double[] doubles = polynom.getCoefficients();
        for (int i = 0; i < doubles.length; i++) {
            builder.append(DoubleFormatter.format(doubles[i]));
            builder.append("x^");
            builder.append(i);
            builder.append(" + ");
        }
        builder.delete(builder.length() - 3, builder.length());
        return builder.toString();
    }


    @NotNull public OPolynom getDerivative()
    {
        PolynomialFunction polynomialDerivative = polynom.polynomialDerivative();
        return new OPolynom(polynomialDerivative);
    }

}
\end{lstlisting}    

\begin{lstlisting}[caption=OSet (Schwenke),label=list:OSet,language=Java]
package de.fhdw.wip.rpntilecalculator.model.operands;

import org.jetbrains.annotations.NotNull;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/*
 * Summary: Every entry can only exist one time
 * Author:  Tim Schwenke
 * Date:    2020/01/04
 */
public class OSet extends Operand {

    @NotNull private Set<Double> set;

    /**
     * Create Set from set.
     * @param set Set
     */
    public OSet(@NotNull Set<Double> set) {
        this.set = set;
    }

    /**
     * Create OSet from array of doubles
     * @param doubles Double array
     */
    public OSet(@NotNull double... doubles) {
        ArrayList<Double> list = new ArrayList<>();
        for (double d : doubles) list.add(d);

        this.set = new HashSet<>();
        this.set.addAll(list);
    }

    /**
     * Create OSet from String
     * @param set String representation of the Set
     */
    public OSet(@NotNull String set) {
        this.set = new HashSet<>();
        Pattern pat = Pattern.compile("[\\-0-9.]+");
        Matcher mat = pat.matcher(set);

        while(mat.find()) {
            this.set.add(Double.valueOf(set.substring(mat.start(), mat.end())));
        }
    }

    /**
     * Get underlying Set
     * @return Set
     */
    @NotNull public Set<Double> getSet() {
        return set;
    }

    /**
     * Turn around all signs
     * @return New OSet
     */
    @NotNull @Override public OSet turnAroundSign() {
        Set<Double> newSet = new HashSet<>();
        for (double d : set)
            newSet.add(d * -1);
        return new OSet(newSet);
    }

    /**
     * Negate all values
     * @return New OSet
     */
    @NotNull @Override public OSet negateValue() {
        Set<Double> newSet = new HashSet<>();
        for (double d : set)
            newSet.add(Math.abs(d) * -1);
        return new OSet(newSet);
    }

    /**
     * Inverse all values
     * @return new OSet
     */
    @Override public @NotNull OSet inverseValue() {
        Set<Double> newSet = new HashSet<>();
        for (double d : set)
            newSet.add(1 / d);
        return new OSet(newSet);
    }

    /**
     * Compare this instance with another Operand
     * @param operand Another operand
     * @return Boolean
     */
    @Override public boolean equalsValue(Operand operand) {
        if (operand == this) return true;
        if (!(operand instanceof OSet)) return false;

        return DoubleComparator.isEqual(set, ((OSet) operand).getSet());
    }

    /**
     * Turn this instance into an string.
     * @return String
     */
    @NotNull @Override public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("[");
        for (double d : set) {
            builder.append(DoubleFormatter.format(d));
            builder.append(", ");
        }
        builder.delete(builder.length() - 2, builder.length());
        builder.append("]");
        return builder.toString();
    }

}
\end{lstlisting}    

\begin{lstlisting}[caption=OTuple (Schwenke),label=list:OTuple,language=Java]
package de.fhdw.wip.rpntilecalculator.model.operands;

import org.jetbrains.annotations.NotNull;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/*
 * Summary: Wrapper for the Tuple Operand
 * Author:  Tim Schwenke
 * Date:    2020/01/04
 */
public class OTuple extends Operand {

    @NotNull private double[] tuple;

    /**
     * Create tuple from array of doubles.
     * @param doubles
     */
    public OTuple(@NotNull double... doubles) {
        this.tuple = doubles;
    }

    /**
     * Create tuple from list of doubles
     * @param tuple
     */
    private OTuple(@NotNull List<Double> tuple) {
        this.tuple = new double[tuple.size()];
        for (int i = 0; i < this.tuple.length; i++)
            this.tuple[i] = tuple.get(i);
    }

    /**
     * Create Tuple from String
     * @param tuple Tuple as String
     */
    public OTuple(@NotNull String tuple) {
        ArrayList<Double> listTuple = new ArrayList<>();
        Pattern pat = Pattern.compile("[\\-0-9.]+");
        Matcher mat = pat.matcher(tuple);

        while(mat.find()) {
            String value = tuple.substring(mat.start(), mat.end());
            listTuple.add(Double.valueOf(value));
        }
        this.tuple = new double[2];
        for(int i = 0; i < 2; i++) this.tuple[i] = listTuple.get(i);
    }

    /**
     * Get the underlying Tuple.
     * @return Tuple
     */
    public @NotNull double[] getTuple() {
        return tuple;
    }

    /**
     * Turn around all signs.
     * @return new Tuple.
     */
    @NotNull @Override public OTuple turnAroundSign() {
        List<Double> newTuple = new ArrayList<>();
        for (double d : tuple)
            newTuple.add(d * -1);
        return new OTuple(newTuple);
    }

    /**
     * Negate Value. Make all values negative.
     * @return new Tuple
     */
    @NotNull @Override public OTuple negateValue() {
        List<Double> newTuple = new ArrayList<>();
        for (double d : tuple)
            newTuple.add(Math.abs(d) * -1);
        return new OTuple(newTuple);
    }

    /**
     * Inverse the value of this instance
     * @return New Tuple
     */
    @Override
    public @NotNull OTuple inverseValue() {
        List<Double> newTuple = new ArrayList<>();
        for (double d : tuple)
            newTuple.add(1 / d);
        return new OTuple(newTuple);
    }

    /**
     * Compare this instance with another Operand
     * @param operand Another operand.
     * @return Boolean
     */
    @Override
    public boolean equalsValue(Operand operand) {
        if (operand == this) return true;
        if (!(operand instanceof OTuple)) return false;

        return DoubleComparator.isEqual(tuple, ((OTuple) operand).getTuple());
    }

    /**
     * Turn Operand into String representation
     * @return String
     */
    @NotNull @Override public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("(");
        for (double d : tuple) {
            builder.append(DoubleFormatter.format(d));
            builder.append(", ");
        }
        builder.delete(builder.length() - 2, builder.length());
        builder.append(")");
        return builder.toString();
    }

}
\end{lstlisting}    

\begin{lstlisting}[caption=Operand (Schwenke),label=list:Operand,language=Java]
package de.fhdw.wip.rpntilecalculator.model.operands;

import org.jetbrains.annotations.NotNull;

/*
 * Summary: Main class for all operands that can be used for calculating
 * Author:  Tim Schwenke
 * Date:    2020/01/04
 */
public abstract class Operand extends Element {

    /**
     * Multiplies all values of the {@link Operand} with {@code -1}.
     */
    public abstract @NotNull Operand turnAroundSign();

    /**
     * Makes all values of the {@link Operand} negative.
     */
    public abstract @NotNull Operand negateValue();

    public abstract @NotNull Operand inverseValue();

    public abstract boolean equalsValue(Operand operand);

}
\end{lstlisting}    

\subsubsection{Settings}

\begin{lstlisting}[caption=AllClear (Falk),label=list:AllClear,language=Java]
package de.fhdw.wip.rpntilecalculator.model.settings;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import de.fhdw.wip.rpntilecalculator.presenter.Presenter;

/**
 * Summary: Empties the stack of the presenter
 * Author:  Hendrik Falk
 * Date:    2020/01/26
 */
public class AllClear extends Setting {

    @Contract(pure = true) @NotNull
    public static AllClear getInstance() { return new AllClear(); }

    /**
     * Clears the entire Stack and current input
     */
    @Override
    public boolean call() {
        Presenter.OPERAND_STACK.clear();
        Presenter.resetInputTerm(null);
        Presenter.updateStack();
        return true;
    }

}
\end{lstlisting}    

\begin{lstlisting}[caption=ClearHistory (Falk),label=list:ClearHistory,language=Java]
package de.fhdw.wip.rpntilecalculator.model.settings;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import de.fhdw.wip.rpntilecalculator.presenter.Presenter;

/**
 * Summary: Empties the history stack of the presenter
 * Author:  Hendrik Falk
 * Date:    2020/01/26
 */
public class ClearHistory extends Setting {

    @Contract(pure = true) @NotNull
    public static ClearHistory getInstance() { return new ClearHistory(); }

    /**
     * Clears the entire History
     */
    @Override
    public boolean call() {
        Presenter.HISTORY_STACK.clear();
        Presenter.updateHistoryStack();
        return true;
    }
}

\end{lstlisting}    

\begin{lstlisting}[caption=DeleteEntry (Falk),label=list:DeleteEntry,language=Java]
package de.fhdw.wip.rpntilecalculator.model.settings;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import de.fhdw.wip.rpntilecalculator.presenter.Presenter;

/**
 * Summary: Deletes the last input of the stack
 * Author:  Hendrik Falk
 * Date:    2020/01/26
 */
public class DeleteEntry extends Setting {

    @Contract(pure = true) @NotNull
    public static DeleteEntry getInstance() { return new DeleteEntry(); }

    /**
     * Delete the last entry and resetting the input term
     */
    @Override
    public boolean call() {
        Presenter.OPERAND_STACK.pop();
        Presenter.resetInputTerm(Presenter.OPERAND_STACK.peek());
        Presenter.updateStack();
        return true;
    }
}
\end{lstlisting}    

\begin{lstlisting}[caption=Dot (Falk),label=list:Dot,language=Java]
package de.fhdw.wip.rpntilecalculator.model.settings;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import de.fhdw.wip.rpntilecalculator.presenter.Presenter;

/**
 * Summary: Places a '.' in the input term to create decimal values
 * Author:  Hendrik Falk
 * Date:    2020/02/03
 */
public class Dot extends Setting {

    @Contract(pure = true) @NotNull
    public static Dot getInstance() { return new Dot(); }

    @Override
    public boolean call() {
        if(Presenter.INPUT_TERM.toString().equals(Presenter.INPUT_FINALIZED)) {
            ODouble oDouble = new ODouble(0);
            Presenter.resetInputTerm(oDouble);
            Presenter.OPERAND_STACK.push(oDouble);
        }
        if(!Presenter.INPUT_TERM.toString().contains(".")) Presenter.INPUT_TERM.append(".");
        Presenter.updateStack();
        return true;
    }
}
\end{lstlisting}    

\begin{lstlisting}[caption=Enter (Falk),label=list:Enter,language=Java]
package de.fhdw.wip.rpntilecalculator.model.settings;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import de.fhdw.wip.rpntilecalculator.model.operands.Operand;
import de.fhdw.wip.rpntilecalculator.presenter.Presenter;

/**
 * Summary: Finishes the current input term so that a new input can be created
 * Author:  Hendrik Falk
 * Date:    2020/01/27
 */
public class Enter extends Setting {

    @Contract(pure = true) @NotNull
    public static Enter getInstance() { return new Enter(); }

    /**
     * finalizes an input string
     */
    @Override
    public boolean call() {
        Presenter.INPUT_TERM = new StringBuilder().append(Presenter.INPUT_FINALIZED);
        if(Presenter.OPERAND_STACK.size() != 0) {
            Presenter.add2History(Presenter.OPERAND_STACK.peek());
            Presenter.updateHistoryStack();
        }
        return true;
    }
}

\end{lstlisting}    

\begin{lstlisting}[caption=Inverse (Falk),label=list:Inverse,language=Java]
package de.fhdw.wip.rpntilecalculator.model.settings;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import de.fhdw.wip.rpntilecalculator.presenter.Presenter;
import de.fhdw.wip.rpntilecalculator.model.operands.Operand;

/**
 * Summary: Calculates the inverse of an operand
 * Author:  Hendrik Falk
 * Date:    2020/01/29
 */
public class Inverse extends Setting {

    @Contract(pure = true) @NotNull
    public static Inverse getInstance() { return new Inverse(); }

    /**
     * Changes + values to - and vice versa
     */
    @Override
    public boolean call() {
        if(Presenter.OPERAND_STACK.size() == 0) return false;
        Operand operand = Presenter.OPERAND_STACK.peek();
        Presenter.OPERAND_STACK.pop();
        Operand result = operand.inverseValue();
        Presenter.OPERAND_STACK.push(result);
        Presenter.resetInputTerm(result);
        Presenter.updateStack();
        return true;
    }
}
\end{lstlisting}    

\begin{lstlisting}[caption=LoadLayout (Meinerzhagen),label=list:LoadLayout,language=Java]
package de.fhdw.wip.rpntilecalculator.model.settings;

import android.app.Dialog;
import android.content.DialogInterface;
import android.view.View;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.ListAdapter;
import android.widget.ListView;

import androidx.appcompat.app.AlertDialog;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import de.fhdw.wip.rpntilecalculator.MainActivity;
import de.fhdw.wip.rpntilecalculator.view.layout.TileLayoutFactory;
import de.fhdw.wip.rpntilecalculator.view.layout.TileLayoutLoader;

/**
 * Summary: Creates a load layout menu to load a new layout design
 * Author:  Tim Jonas Meinerzhagen
 * Date:    2020/01/26
 */
public class LoadLayout extends Setting {

    @Contract(pure = true) @NotNull
    public static LoadLayout getInstance() { return new LoadLayout(); }

    /**
     * Clears the entire Stack and current input
     */
    @Override
    public boolean call() {
        final MainActivity activity = MainActivity.mainActivity;

        final Dialog dialog = new Dialog(activity);

        LinearLayout l = new LinearLayout(activity.getBaseContext());
        for(final String s : TileLayoutLoader.getSavedLayouts(activity.getBaseContext())){
            Button b = new Button(activity.getBaseContext());
            b.setText(s);
            b.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View view) {
                    dialog.cancel();
                    activity.setTileLayout(TileLayoutFactory.createLayout(activity.getBaseContext(), s));
                }
            });
            l.addView(b);
        }
        dialog.addContentView(l,
                new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT));
        dialog.setCancelable(true);
        dialog.show();

        return true;
    }

}
\end{lstlisting}    

\begin{lstlisting}[caption=SaveLayout (Meinerzhagen),label=list:SaveLayout,language=Java]
package de.fhdw.wip.rpntilecalculator.model.settings;

import android.app.Dialog;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.LinearLayout;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import de.fhdw.wip.rpntilecalculator.MainActivity;
import de.fhdw.wip.rpntilecalculator.view.Tile;
import de.fhdw.wip.rpntilecalculator.view.layout.TileLayout;
import de.fhdw.wip.rpntilecalculator.view.layout.TileLayoutFactory;
import de.fhdw.wip.rpntilecalculator.view.layout.TileLayoutLoader;

/**
 * Summary: Creates a save layout menu to save the current design
 * Author:  Tim Jonas Meinerzhagen
 * Date:    2020/01/26
 */
public class SaveLayout extends Setting {

    @Contract(pure = true) @NotNull
    public static SaveLayout getInstance() { return new SaveLayout(); }

    /**
     * Clears the entire Stack and current input
     */
    @Override
    public boolean call() {
        final MainActivity activity = MainActivity.mainActivity;
        final Dialog dialog = new Dialog(activity);

        LinearLayout l = new LinearLayout(activity.getBaseContext());
        final EditText text = new EditText(activity.getBaseContext());
        text.setText("Main");
        Button b = new Button(activity.getBaseContext());
        b.setText("Save");
        b.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                dialog.cancel();
                TileLayout t = activity.getTileLayout();
                t.setIndicator(text.getText().toString());
                TileLayoutLoader.saveLayout(activity.getBaseContext(), t);
                t.showAnimation(Tile.buttonSave);
            }
        });
        l.addView(text);
        l.addView(b);
        dialog.addContentView(l,
                new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT));
        dialog.setCancelable(true);
        dialog.show();

        return true;
    }

}
\end{lstlisting}    

\begin{lstlisting}[caption=Setting (Falk),label=list:Setting,language=Java]
package de.fhdw.wip.rpntilecalculator.model.settings;

import org.jetbrains.annotations.Contract;

/**
 * Summary: Super class for settings
 * Author:  Hendrik Falk
 * Date:    2020/01/26
 */
public abstract class Setting {

    @Contract(pure = true)
    public abstract boolean call();
}

\end{lstlisting}    

\begin{lstlisting}[caption=Split (Falk),label=list:Split,language=Java]
package de.fhdw.wip.rpntilecalculator.model.settings;

import org.apache.commons.math3.linear.RealMatrix;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Set;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import de.fhdw.wip.rpntilecalculator.model.operands.OMatrix;
import de.fhdw.wip.rpntilecalculator.model.operands.OSet;
import de.fhdw.wip.rpntilecalculator.model.operands.OTuple;
import de.fhdw.wip.rpntilecalculator.model.operands.Operand;
import de.fhdw.wip.rpntilecalculator.presenter.Presenter;

/**
 * Summary: Splits the current loaded operand into several ODoubles
 * Author:  Hendrik Falk
 * Date:    2020/02/03
 */
public class Split extends Setting {

    @Contract(pure = true) @NotNull
    public static Split getInstance() { return new Split(); }

    /**
     * Splits a set / matrix / vektor / tuple into multiple ODouble values
     */
    @Override
    public boolean call() {
        if(Presenter.OPERAND_STACK.size() == 0) return false;

        Operand toSplit = Presenter.OPERAND_STACK.peek();
        List<ODouble> operandList = new ArrayList<>();

        if(toSplit instanceof OMatrix) {

            RealMatrix matrix = ((OMatrix) toSplit).getMatrix();
            int rowsCount = matrix.getRowDimension();
            for(int i = 0; i < rowsCount; i++) {
                double[] row = matrix.getRow(i);
                for(double value : row) operandList.add(new ODouble(value));
            }

        } else if(toSplit instanceof OSet) {

            @NotNull Set<Double> set = ((OSet) toSplit).getSet();
            for(double value : set) operandList.add(new ODouble(value));

        } else if(toSplit instanceof OTuple) {

            double[] tuple = ((OTuple) toSplit).getTuple();
            for(double value : tuple) operandList.add(new ODouble(value));

        }

        if(operandList.size() != 0) {
            Presenter.OPERAND_STACK.pop();

            Collections.reverse((operandList));
            for(ODouble oDouble : operandList) {
                Presenter.add2History(oDouble);
                Presenter.OPERAND_STACK.push(oDouble);
            }

            Presenter.updateStack();
            Presenter.updateHistoryStack();
        }
        return true;
    }
}
\end{lstlisting}    

\begin{lstlisting}[caption=Swap (Falk),label=list:Swap,language=Java]
package de.fhdw.wip.rpntilecalculator.model.settings;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import de.fhdw.wip.rpntilecalculator.presenter.Presenter;
import de.fhdw.wip.rpntilecalculator.model.operands.Operand;

/**
 * Summary: Swaps the last two stack operands
 * Author:  Hendrik Falk
 * Date:    2020/01/30
 */
public class Swap extends Setting {

    @Contract(pure = true) @NotNull
    public static Swap getInstance() { return new Swap(); }

    /**
     * Swap the last entry with the one before
     */
    @Override
    public boolean call() {
        if(Presenter.OPERAND_STACK.size() < 2) return false;

        Operand one = Presenter.OPERAND_STACK.pop();
        Operand two = Presenter.OPERAND_STACK.pop();

        Presenter.OPERAND_STACK.push(one);
        Presenter.OPERAND_STACK.push(two);
        Presenter.resetInputTerm(two);

        Presenter.updateStack();
        return true;
    }
}

\end{lstlisting}    

\begin{lstlisting}[caption=TurnAroundSign (Falk),label=list:TurnAroundSign,language=Java]
package de.fhdw.wip.rpntilecalculator.model.settings;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import de.fhdw.wip.rpntilecalculator.presenter.Presenter;
import de.fhdw.wip.rpntilecalculator.model.operands.Operand;

/**
 * Summary: Changes positive operands to negative ones and vice versa
 * Author:  Hendrik Falk
 * Date:    2020/01/30
 */
public class TurnAroundSign extends Setting {

    @Contract(pure = true) @NotNull
    public static TurnAroundSign getInstance() { return new TurnAroundSign(); }

    /**
     * Changes + values to - and vice versa
     */
    @Override
    public boolean call() {
        if(Presenter.OPERAND_STACK.size() == 0) return false;
        Operand operand = Presenter.OPERAND_STACK.peek();
        Presenter.OPERAND_STACK.pop();
        Operand result = operand.turnAroundSign();
        Presenter.OPERAND_STACK.push(result);
        Presenter.resetInputTerm(result);
        Presenter.updateStack();
        return true;
    }
}
\end{lstlisting} 

\subsubsection{Stack}   

\begin{lstlisting}[caption=StackInterface (Schwenke),label=list:StackInterface,language=Java]
package de.fhdw.wip.rpntilecalculator.model.stack;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.List;

/**
 * Summary: Stack interface for stacks in this project
 * Author:  Tim Schwenke
 * Date:    2020/01/04
 */
public interface StackInterface<T> {

    /**
     * Push a single object onto the stack
     * @param value Object
     */
    void push(@NotNull T value);

    /**
     * Push an array of objects onto the stack
     * @param values Array of objects
     */
    void push(@NotNull T[] values);

    /**
     * Pop an object from the stack
     * @return Object
     */
    @Nullable T pop();

    /**
     * Pop a certain amount of objects from the stack
     * @param max Max amount of objects to pop
     * @return List of popped items
     */
    @NotNull List<T> pop(int max);

    /**
     * Pop a element of a certain class from the stack
     * @param type Type of the element to be popped
     * @param <G> Class the type to be popped should extend
     * @return Popped item
     */
    @Nullable <G extends T> G pop(Class<G> type);

    /**
     * Pop a certain amount of elements of a certain type from the stack.
     * @param max Max amount of items to pop
     * @param type Type the items should be
     * @param <G> Class the items should extend
     * @return List of popped items
     */
    @NotNull <G extends T> List<G> pop(int max, Class<G> type);

    /**
     * Peek the first item on the stack
     * @return Item peeked
     */
    @Nullable T peek();

    /**
     * Peek a list of items on the stack.
     * @param max Max amount of items to peek
     * @return A list of items that were peeked
     */
    @NotNull List<T> peek(int max);

    /**
     * Peek the first item of a certain type on the stack.
     * @param type Type the item should be
     * @param <G> Class the item should extend
     * @return Peeked item
     */
    @Nullable <G extends T> G peek(Class<G> type);

    /**
     * Peek a list of items that are all of a certain type on the stack
     * @param max Max amount of items to be peeked from the stack
     * @param type Type the peeked items should be
     * @param <G> Class the peeked items should extend
     * @return List of items that were peeked
     */
    @NotNull <G extends T> List<G> peek(int max, Class<G> type);

    /**
     * Check if a certain object is part of the stack
     * @param object Object to be searched for on the stack
     * @return Boolean
     */
    boolean contains(T object);

    /**
     * Clear the stack
     */
    void clear();

    /**
     * Get the stack as an copy in an array.
     * @return Array
     */
    @NotNull T[] get();

    /**
     * Get all items of a certain type from the stack
     * @param type Type the items should be
     * @param <G> Class items should extend
     * @return List
     */
    @NotNull <G extends T> List<G> get(Class<G> type);

    /**
     * Size of the stack
     * @return number of items on the stack
     */
    int size();

}
\end{lstlisting}    

\begin{lstlisting}[caption=OperandStack (Schwenke),label=list:OperandStack,language=Java]
package de.fhdw.wip.rpntilecalculator.model.stack;

import de.fhdw.wip.rpntilecalculator.model.operands.Operand;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.ArrayList;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;

/*
 * Summary: The Stack for the operands that is used for calculating
 * Author:  Tim Schwenke
 * Date:    2020/01/04
 */
public final class OperandStack implements StackInterface<Operand> {

    private final LinkedList<Operand> linkedList = new LinkedList<>();
    private final List<Operand> listView = linkedList;
    private final Deque<Operand> dequeView = linkedList;

    @Override public void push(@NotNull Operand operand) {
        dequeView.push(operand);
    }

    @Override public void push(@NotNull Operand[] operands) {
        for (Operand value : operands) dequeView.push(value);
    }

    @Override public @Nullable Operand pop() {
        try { return dequeView.pop(); }
        catch (RuntimeException e) { return null; }
    }

    @Override public @NotNull List<Operand> pop(int max) {
        List<Operand> list = new ArrayList<>();
        while (!linkedList.isEmpty() && list.size() < max)
            list.add(dequeView.pop());
        return list;
    }

    @Override public @Nullable <G extends Operand> G pop(Class<G> type) {
        for (int i = 0; i < listView.size(); i++) {
            if (type.isInstance(listView.get(i)))
                return type.cast(linkedList.remove(i));
        }
        return null;
    }

    @Override public @NotNull <G extends Operand> List<G> pop(int max, Class<G> type) {
        List<G> list = new ArrayList<>();
        for (int i = 0; i < linkedList.size(); i++) {
            if (list.size() < max && type.isInstance(linkedList.get(i))) {
                list.add(type.cast(linkedList.remove(i--)));
            }
        }
        return list;
    }

    @Override public @Nullable Operand peek() {
        try { return dequeView.peek(); }
        catch (RuntimeException e) { return null; }
    }

    @Override public @NotNull List<Operand> peek(int max) {
        List<Operand> list = new ArrayList<>();
        for (int i = 0; i < listView.size(); i++)
            if (list.size() < max)
                list.add(listView.get(i));
        return list;
    }

    @Override public @Nullable <G extends Operand> G peek(Class<G> type) {
        for (int i = 0; i < listView.size(); i++) {
            Operand operand = listView.get(i);
            if (type.isInstance(operand))
                return type.cast(operand);
        }
        return null;
    }

    @Override public @NotNull <G extends Operand> List<G> peek(int max, Class<G> type) {
        List<G> list = new ArrayList<>();
        for (int i = 0; i < listView.size(); i++) {
            Operand operand = listView.get(i);
            if (list.size() < max && type.isInstance(operand))
                list.add(type.cast(operand));
        }
        return list;
    }

    @Override public boolean contains(Operand object) {
        return linkedList.contains(object);
    }

    @Override public void clear() {
        linkedList.clear();
    }

    @NotNull @Override public Operand[] get() {
        return linkedList.toArray(new Operand[0]);
    }

    @NotNull @Override public <G extends Operand> List<G> get(Class<G> type) {
        List<G> list = new ArrayList<>();
        for (Operand operand : listView)
            if (type.isInstance(operand))
                list.add(type.cast(operand));
        return list;
    }

    @Override public int size() {
        return linkedList.size();
    }

    public void print() {
        for (int i = 0; i < listView.size(); i++)
            System.out.println(i + ": " + listView.get(i));
    }

}

\end{lstlisting} 

\begin{lstlisting}[caption=ArcCosinusTest (Keienburg),label=list:ArcCosinusTest,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.junit.Test;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;

import static org.junit.Assert.assertTrue;

/*
 * Summary: Unit test for the arc cosinus function
 * Author:  Jannis Luca Keienburg
 * Date:    2020/01/22
 */

public class ArcCosinusTest {
    private ArcCosinus ARC_COSINUS = ArcCosinus.getInstance();

    @Test
    public void arcCosinusAngle_isCorrect1() {
        System.out.println(ARC_COSINUS.on(
                new ODouble(10)));
        assertTrue(ARC_COSINUS.on(
                new ODouble(10)).equalsValue(new ODouble(1.3953649341158527))
        );
    }

    @Test
    public void arcCosinusAngle_isCorrect2() {
        System.out.println(ARC_COSINUS.on(
                new ODouble(45)));
        assertTrue(ARC_COSINUS.on(
                new ODouble(45)).equalsValue(new ODouble(0.6674572160283838))
        );
    }

    @Test
    public void arcCosinusAngle_isCorrect3() {
        System.out.println(ARC_COSINUS.on(
                new ODouble(-45)));
        assertTrue(ARC_COSINUS.on(
                new ODouble(-45)).equalsValue(new ODouble(-0.6674572160283838))
        );
    }
}
\end{lstlisting} 

\begin{lstlisting}[caption=ArcSinusTest (Keienburg),label=list:ArcSinusTest,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.junit.Test;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;

import static org.junit.Assert.assertTrue;

/*
 * Summary: Unit test for the arc sinus function
 * Author:  Jannis Luca Keienburg
 * Date:    2020/01/22
 */

public class ArcSinusTest {
    private ArcSinus ARC_SINUS = ArcSinus.getInstance();

    @Test
    public void arcSinusAngle_isCorrect1() {
        System.out.println(ARC_SINUS.on(
                new ODouble(10)));
        assertTrue(ARC_SINUS.on(
                new ODouble(10)).equalsValue(new ODouble(0.17543139267904395))
        );
    }

    @Test
    public void arcSinusAngle_isCorrect2() {
        System.out.println(ARC_SINUS.on(
                new ODouble(45)));
        assertTrue(ARC_SINUS.on(
                new ODouble(45)).equalsValue(new ODouble(0.9033391107665127))
        );
    }

    @Test
    public void arcSinusAngle_isCorrect3() {
        System.out.println(ARC_SINUS.on(
                new ODouble(-45)));
        assertTrue(ARC_SINUS.on(
                new ODouble(-45)).equalsValue(new ODouble(-0.9033391107665127))
        );
    }
}
\end{lstlisting} 

\begin{lstlisting}[caption=ArcTangensTest (Keienburg),label=list:ArcTangensTest,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.junit.Test;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;

import static org.junit.Assert.assertTrue;

/*
 * Summary: Unit test for the arc tangens function
 * Author:  Jannis Luca Keienburg
 * Date:    2020/01/22
 */

public class ArcTangensTest {
    private ArcTangens ARC_TANGENS = ArcTangens.getInstance();

    @Test
    public void arcTangensAngle_isCorrect1() {
        System.out.println(ARC_TANGENS.on(
                new ODouble(10)));
        assertTrue(ARC_TANGENS.on(
                new ODouble(10)).equalsValue(new ODouble(0.1727924348551592))
        );
    }

    @Test
    public void arcTangensAngle_isCorrect2() {
        System.out.println(ARC_TANGENS.on(
                new ODouble(45)));
        assertTrue(ARC_TANGENS.on(
                new ODouble(45)).equalsValue(new ODouble(0.6657737500283538))
        );
    }

    @Test
    public void arcTangensAngle_isCorrect3() {
        System.out.println(ARC_TANGENS.on(
                new ODouble(-45)));
        assertTrue(ARC_TANGENS.on(
                new ODouble(-45)).equalsValue(new ODouble(-0.6657737500283538))
        );
    }
}
\end{lstlisting} 

\begin{lstlisting}[caption=CosinusTest (Keienburg),label=list:CosinusTest,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.junit.Test;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;

import static org.junit.Assert.assertTrue;

/*
 * Summary: Unit test for the cosinus function
 * Author:  Jannis Luca Keienburg
 * Date:    2020/01/22
 */

public class CosinusTest {
    private Cosinus COSINUS = Cosinus.getInstance();

    @Test public void cosinusAngle_isCorrect1() {
        System.out.println(COSINUS.on(
                new ODouble(10)));
        assertTrue(COSINUS.on(
                new ODouble(10)).equalsValue(new ODouble(0.984807753012208))
        );
    }

    @Test public void cosinusAngle_isCorrect2() {
        System.out.println(COSINUS.on(
                new ODouble(45)));
        assertTrue(COSINUS.on(
                new ODouble(45)).equalsValue(new ODouble(0.7071067811865476))
        );
    }

    @Test public void cosinusAngle_isCorrect3() {
        System.out.println(COSINUS.on(
                new ODouble(-45)));
        assertTrue(COSINUS.on(
                new ODouble(-45)).equalsValue(new ODouble(-0.7071067811865476))
        );
    }
}
\end{lstlisting} 

\begin{lstlisting}[caption=DerivationTest (Keienburg),label=list:DerivationTest,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;
import org.junit.Test;

import de.fhdw.wip.rpntilecalculator.model.operands.OPolynom;
import de.fhdw.wip.rpntilecalculator.model.operands.OTuple;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

/*
 * Summary: Unit test for the derivation
 * Author:  Jannis Luca Keienburg
 * Date:    2020/01/23
 */

public class DerivationTest {
    private Derivation DERIVATION = Derivation.getInstance();

    @Test
    public void derivation_isCorrect1() {
        double[] functionValues = new double[] {2, 4, 6};
        OPolynom function = new OPolynom(new PolynomialFunction(functionValues));
        double[] resultValues = new double[] {4, 4};
        OPolynom derivation = new OPolynom(new PolynomialFunction(resultValues));
        assertEquals(DERIVATION.on(function), derivation);
    }

    @Test
    public void derivation_isCorrect2() {
        double[] functionValues = new double[] {7, 9};
        OPolynom function = new OPolynom(new PolynomialFunction(functionValues));
        double[] resultValues = new double[] {7};
        OPolynom derivation = new OPolynom(new PolynomialFunction(resultValues));
        assertEquals(DERIVATION.on(function), derivation);
    }

    @Test
    public void derivation_isCorrect3() {
        double[] functionValues = new double[] {12, -3, 12};
        OPolynom function = new OPolynom(new PolynomialFunction(functionValues));
        double[] resultValues = new double[] {24, -3};
        OPolynom derivation = new OPolynom(new PolynomialFunction(resultValues));
        assertEquals(DERIVATION.on(function), derivation);
    }

    @Test
    public void derivation_isCorrect4() {
        double[] functionValues = new double[] {-3, 4, 12};
        OPolynom function = new OPolynom(new PolynomialFunction(functionValues));
        double[] resultValues = new double[] {-6, 4};
        OPolynom derivation = new OPolynom(new PolynomialFunction(resultValues));
        assertEquals(DERIVATION.on(function), derivation);
    }

    @Test
    public void derivation_isCorrect5() {
        double[] functionValues = new double[] {1.5, 2, 7};
        OPolynom function = new OPolynom(new PolynomialFunction(functionValues));
        double[] resultValues = new double[] {2,25, 2};
        OPolynom derivation = new OPolynom(new PolynomialFunction(resultValues));
        assertEquals(DERIVATION.on(function), derivation);
    }
}
\end{lstlisting} 

\begin{lstlisting}[caption=HighAndLowPointsTest (Keienburg),label=list:HighAndLowPointsTest,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;
import org.junit.Test;

import de.fhdw.wip.rpntilecalculator.model.operands.OPolynom;
import de.fhdw.wip.rpntilecalculator.model.operands.OTuple;

import static org.junit.Assert.assertEquals;

/*
 * Summary: Unit test for the calculation of high and low points
 * Author:  Jannis Luca Keienburg
 * Date:    2020/01/23
 */

public class HighAndLowPointsTest {
    private HighAndLowPoints HIGHANDLOWPOINTS = HighAndLowPoints.getInstance();

    @Test
    public void highAndLowPoints_isCorrect1() {
        double[] functionValues = new double[]{2, 4, 6};
        OPolynom function = new OPolynom(new PolynomialFunction(functionValues));
        double[] resultValues = new double[]{-1, 4};
        OTuple extremPoints = new OTuple(resultValues);
        assertEquals(HIGHANDLOWPOINTS.on(function), extremPoints);
    }

    @Test
    public void highAndLowPoints_isCorrect2() {
        double[] functionValues = new double[]{3, 6,-4};
        OPolynom function = new OPolynom(new PolynomialFunction(functionValues));
        double[] resultValues = new double[]{-1, -1};
        OTuple extremPoints = new OTuple(resultValues);
        assertEquals(HIGHANDLOWPOINTS.on(function), extremPoints);
    }

    @Test
    public void highAndLowPoints_isCorrect3() {
        double[] functionValues = new double[]{-2, 4, 12};
        OPolynom function = new OPolynom(new PolynomialFunction(functionValues));
        double[] resultValues = new double[]{1, 14};
        OTuple extremPoints = new OTuple(resultValues);
        assertEquals(HIGHANDLOWPOINTS.on(function), extremPoints);
    }

    @Test
    public void highAndLowPoints_isCorrect4() {
        double[] functionValues = new double[]{1, 2, 6, 5};
        OPolynom function = new OPolynom(new PolynomialFunction(functionValues));
        double[] resultValues = new double[]{};
        OTuple extremPoints = new OTuple(resultValues);
        assertEquals(HIGHANDLOWPOINTS.on(function), extremPoints);
    }
}
\end{lstlisting} 

\begin{lstlisting}[caption=Logarithm10Test (Keienburg),label=list:Logarithm10Test,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.junit.Test;
import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import static org.junit.Assert.assertTrue;

/*
 * Summary: Unit test for the logarithm with base 10. 
 * Author:  Jannis Luca Keienburg
 * Date:    2020/01/22
 */

public class Logarithm10Test {
    private Logarithm10 LOGARITHM10 = Logarithm10.getInstance();

    @Test
    public void naturalLogarithm_isCorrect1() {
        System.out.println(LOGARITHM10.on(
                new ODouble(10)));
        assertTrue(LOGARITHM10.on(
                new ODouble(10)).equalsValue(new ODouble(1.0))
        );
    }

    @Test
    public void naturalLogarithm_isCorrect2() {
        System.out.println(LOGARITHM10.on(
                new ODouble(5)));
        assertTrue(LOGARITHM10.on(
                new ODouble(5)).equalsValue(new ODouble(0.6989700043360189))
        );
    }

    @Test
    public void naturalLogarithm_isCorrect3() {
        System.out.println(LOGARITHM10.on(
                new ODouble(97)));
        assertTrue(LOGARITHM10.on(
                new ODouble(97)).equalsValue(new ODouble(1.9867717342662448))
        );
    }
}
\end{lstlisting} 

\begin{lstlisting}[caption=LogarithmTest (Keienburg),label=list:LogarithmTest,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.junit.Test;

import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;

import static org.junit.Assert.assertTrue;

/*
 * Summary: Unit test for the natural logarithm and logatithm with specific base
 * Author:  Jannis Luca Keienburg
 * Date:    2020/01/22
 */

public class LogarithmTest {
    private Logarithm LOGARITHM = Logarithm.getInstance();

    @Test
    public void naturalLogarithm_isCorrect1() {
        System.out.println(LOGARITHM.on(
                new ODouble(10)));
        assertTrue(LOGARITHM.on(
                new ODouble(10)).equalsValue(new ODouble(2.302585092994046))
        );
    }

    @Test
    public void naturalLogarithm_isCorrect2() {
        System.out.println(LOGARITHM.on(
                new ODouble(5)));
        assertTrue(LOGARITHM.on(
                new ODouble(5)).equalsValue(new ODouble(1.6094379124341003))
        );
    }

    @Test
    public void naturalLogarithm_isCorrect3() {
        System.out.println(LOGARITHM.on(
                new ODouble(97)));
        assertTrue(LOGARITHM.on(
                new ODouble(97)).equalsValue(new ODouble(4.574710978503383))
        );
    }

    @Test
    public void naturalLogarithm_isCorrect4() {
        System.out.println(LOGARITHM.on(
                new ODouble(Math.exp(1))));
        assertTrue(LOGARITHM.on(
                new ODouble(Math.exp(1))).equalsValue(new ODouble(1))
        );
    }

    @Test
    public void logarithmOfChoosenBase_isCorrect1() {
        System.out.println(LOGARITHM.on(
                new ODouble(5),
                new ODouble(10)));
        assertTrue(LOGARITHM.on(
                new ODouble(5),
                new ODouble(10))
                .equalsValue(new ODouble(1.4306765580733933))
        );
    }

    @Test
    public void logarithmOfChoosenBase_isCorrect2() {
        System.out.println(LOGARITHM.on(
                new ODouble(10),
                new ODouble(10)));
        assertTrue(LOGARITHM.on(
                new ODouble(10),
                new ODouble(10))
                .equalsValue(new ODouble(1.0))
        );
    }

    @Test
    public void logarithmOfChoosenBase_isCorrect3() {
        System.out.println(LOGARITHM.on(
                new ODouble(Math.exp(1)),
                new ODouble(10)));
        assertTrue(LOGARITHM.on(
                new ODouble(Math.exp(1)),
                new ODouble(10))
                .equalsValue(new ODouble(2.302585092994046))
        );
    }
}
\end{lstlisting} 

\begin{lstlisting}[caption=SinusTest (Keienburg),label=list:SinusTest,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.junit.Test;
import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import static org.junit.Assert.assertTrue;

/*
 * Summary: Unit test for the sinus function
 * Author:  Jannis Luca Keienburg
 * Date:    2020/01/22
 */

public class SinusTest {
    private Sinus SINUS = Sinus.getInstance();

    @Test public void sinusAngle_isCorrect1() {
        System.out.println(SINUS.on(
                new ODouble(10)));
        assertTrue(SINUS.on(
                new ODouble(10)).equalsValue(new ODouble(0.17364817766693033))
        );
    }

    @Test public void sinusAngle_isCorrect2() {
        System.out.println(SINUS.on(
                new ODouble(45)));
        assertTrue(SINUS.on(
                new ODouble(45)).equalsValue(new ODouble(0.7071067811865475))
        );
    }

    @Test public void sinusAngle_isCorrect3() {
        System.out.println(SINUS.on(
                new ODouble(-45)));
        assertTrue(SINUS.on(
                new ODouble(-45)).equalsValue(new ODouble(-0.7071067811865475))
        );
    }
}
\end{lstlisting} 

\begin{lstlisting}[caption=TangensTest (Schwenke),label=list:TangensTest,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.junit.Test;
import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import static org.junit.Assert.assertTrue;

/*
 * Summary: Unit test for the tangens
 * Author:  Jannis Luca Keienburg
 * Date:    2020/01/22
 */

public class TangensTest {
    private Tangens TANGENS = Tangens.getInstance();

    @Test
    public void tangensAngle_isCorrect1() {
        System.out.println(TANGENS.on(
                new ODouble(10)));
        assertTrue(TANGENS.on(
                new ODouble(10)).equalsValue(new ODouble(0.17632698070846498))
        );
    }

    @Test
    public void tangensAngle_isCorrect2() {
        System.out.println(TANGENS.on(
                new ODouble(45)));
        assertTrue(TANGENS.on(
                new ODouble(45)).equalsValue(new ODouble(0.9999999999999999))
        );
    }

    @Test
    public void tangensAngle_isCorrect3() {
        System.out.println(TANGENS.on(
                new ODouble(-45)));
        assertTrue(TANGENS.on(
                new ODouble(-45)).equalsValue(new ODouble(-0.9999999999999999))
        );
    }
}
\end{lstlisting} 

\begin{lstlisting}[caption=ZerosTest (Schwenke),label=list:ZerosTest,language=Java]
package de.fhdw.wip.rpntilecalculator.model.calculation;

import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;
import org.junit.Test;
import de.fhdw.wip.rpntilecalculator.model.operands.ODouble;
import de.fhdw.wip.rpntilecalculator.model.operands.OPolynom;
import de.fhdw.wip.rpntilecalculator.model.operands.OTuple;
import static org.junit.Assert.assertTrue;

/*
 * Summary: Unit test for the calculation of the zeros
 * Author:  Jannis Luca Keienburg
 * Date:    2020/01/23
 */

public class ZerosTest {
    private Zeros ZEROS = Zeros.getInstance();

    @Test
    public void zeros_isCorrect1() {
        double[] functionValues = new double[] {2, 4};
        OPolynom function = new OPolynom(new PolynomialFunction(functionValues));
        OTuple result = new OTuple(2, 0);
        System.out.println(ZEROS.on(function));
        assertTrue(ZEROS.on(new OPolynom(new PolynomialFunction(functionValues)))
                .equalsValue(result));
    }

    @Test
    public void zeros_isCorrect2() {
        double[] functionValues = new double[] {3, 4, 6};
        OPolynom function = new OPolynom(new PolynomialFunction(functionValues));
        OTuple result = new OTuple();
        System.out.println(ZEROS.on(function));
        assertTrue(ZEROS.on(new OPolynom(new PolynomialFunction(functionValues)))
                .equalsValue(result));
    }

    @Test
    public void zeros_isCorrect3() {
        double[] functionValues = new double[] {1, 4, -4};
        OPolynom function = new OPolynom(new PolynomialFunction(functionValues));
        OTuple result = new OTuple(-4.828, 0.828);
        System.out.println(ZEROS.on(function));
        assertTrue(ZEROS.on(new OPolynom(new PolynomialFunction(functionValues)))
                .equalsValue(result));
    }
}
\end{lstlisting} 

\subsection{View}

\subsubsection{Layout}

\begin{lstlisting}[caption=ScreenOrientation,label=list:ScreenOrientation,language=Java]
XXX
\end{lstlisting}    

\begin{lstlisting}[caption=StorageLoadingException,label=list:StorageLoadingException,language=Java]
XXX
\end{lstlisting}    

\begin{lstlisting}[caption=TileLayout,label=list:TileLayout,language=Java]
XXX
\end{lstlisting}    

\begin{lstlisting}[caption=TileLayoutFactory,label=list:TileLayoutFactory,language=Java]
XXX
\end{lstlisting}    

\begin{lstlisting}[caption=TileLayoutLoader,label=list:TileLayoutLoader,language=Java]
XXX
\end{lstlisting}   

\subsubsection{Menu} 

\begin{lstlisting}[caption=ChooseListMenu,label=list:ChooseListMenu,language=Java]
XXX
\end{lstlisting}    

\begin{lstlisting}[caption=DialogMenu,label=list:DialogMenu,language=Java]
XXX
\end{lstlisting}    

\begin{lstlisting}[caption=InputDouble,label=list:InputDouble,language=Java]
XXX
\end{lstlisting}    

\begin{lstlisting}[caption=InputFraction,label=list:InputFraction,language=Java]
XXX
\end{lstlisting}    

\begin{lstlisting}[caption=InputMenuFactory,label=list:InputMenuFactory,language=Java]
XXX
\end{lstlisting}    

\begin{lstlisting}[caption=InputPolynomial,label=list:InputPolynomial,language=Java]
XXX
\end{lstlisting}    

\begin{lstlisting}[caption=InputTileType,label=list:InputTileType,language=Java]
XXX
\end{lstlisting}    

\subsubsection{Schemas}

\begin{lstlisting}[caption=ActionTileScheme,label=list:ActionTileScheme,language=Java]
XXX
\end{lstlisting}    

\begin{lstlisting}[
caption=ErrorTileScheme,
label=list:ErrorTileScheme,
language=Java]
XXX
\end{lstlisting}    

\begin{lstlisting}[caption=HistoryTileScheme,label=list:HistoryTileScheme,language=Java]
XXX
\end{lstlisting}    

\begin{lstlisting}[caption=OperandTileScheme,label=list:OperandTileScheme,language=Java]
XXX
\end{lstlisting}    

\begin{lstlisting}[caption=SettingTileScheme,label=list:SettingTileScheme,language=Java]
XXX
\end{lstlisting}    

\begin{lstlisting}[caption=StackTileScheme,label=list:StackTileScheme,language=Java]
XXX
\end{lstlisting}    

\begin{lstlisting}[caption=TileScheme,label=list:TileScheme,language=Java]
XXX
\end{lstlisting}

\subsubsection{Sonstiges}

\begin{lstlisting}[caption=Tile,label=list:Tile,language=Java]
XXX
\end{lstlisting}    

\begin{lstlisting}[caption=TileMapping,label=list:TileMapping,language=Java]
XXX
\end{lstlisting}    

\begin{lstlisting}[caption=TileType,label=list:TileType,language=Java]
XXX
\end{lstlisting}    

\begin{lstlisting}[caption=TypeQuestionable,label=list:TypeQuestionable,language=Java]
XXX
\end{lstlisting}    

\begin{lstlisting}[caption=MainActivity,label=list:MainActivity,language=Java]
XXX
\end{lstlisting} 

\subsection{Presenter}

\begin{lstlisting}[caption=Presenter,label=list:Presenter,language=Java]
XXX
\end{lstlisting}    
